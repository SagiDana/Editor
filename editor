#!/usr/bin/python3

from signal import signal, SIGWINCH
from string import printable
import timeout_decorator
import argparse
import time
import json
import re
import os

from settings import g_settings
from buffer import Buffer
from window import Window
from screen import *
from log import elog
from tab import Tab

from events import *
from hooks import *

args = None

NORMAL = 'normal'
INSERT = 'insert'
VISUAL = 'visual'
VISUAL_LINE = 'visual_line'
VISUAL_BLOCK = 'visual_block'
REPLACE = 'replace'
MAP_TIMEOOUT = 2 # in seconds

class Editor():
    def on_buffer_destroy_after_callback(self, buf): 
        self.buffers.remove(buf)

    def on_buffer_create_after_callback(self, buf): 
        self.buffers.append(buf)

    def draw(self):
        self.get_curr_tab().draw()
        pass

    @timeout_decorator.timeout(MAP_TIMEOOUT)
    def get_key_timeout(self):
        return self.screen.get_key()

    def change_mode(self, target):
        if self.mode == INSERT and target == NORMAL:
            self.get_curr_window().change_end()
        if self.mode == NORMAL and target == INSERT:
            # in vim the transition from insert mode to normal mode causes the
            # cursor to move one index to the left. should I mimic this?
            self.get_curr_window().change_begin()
        if self.mode == NORMAL and target == VISUAL_LINE:
            self.get_curr_window().visual_begin(VISUAL_LINE)
        if self.mode == NORMAL and target == VISUAL:
            self.get_curr_window().visual_begin(VISUAL)
        if self.mode == VISUAL and target == NORMAL:
            self.get_curr_window().visual_end()
        if self.mode == VISUAL_LINE and target == NORMAL:
            self.get_curr_window().visual_end()

        self.mode = target

    def get_inner_key(self):
        try: return self.get_key_timeout()
        except: return None

    def initialize_theme(self):
        with open(self.config['theme_path'], 'r') as f: 
            self.theme = json.loads(f.read())

    def _initialize_legends_maps(self, mode):
        # Legends
        def j_map(self):
            self.get_curr_window().move_down()
            return False
        self.maps[mode][ord('j')] = j_map
        def k_map(self):
            self.get_curr_window().move_up()
            return False
        self.maps[mode][ord('k')] = k_map
        def l_map(self):
            self.get_curr_window().move_right()
            return False
        self.maps[mode][ord('l')] = l_map
        def h_map(self):
            self.get_curr_window().move_left()
            return False
        self.maps[mode][ord('h')] = h_map

    def _initialize_normal_window_maps(self):
        self.maps[NORMAL][CTRL_W_KEY] = {}
        def ctrl_w_s_map(self):
            self.get_curr_tab().split()
            return False
        self.maps[NORMAL][CTRL_W_KEY][ord('s')] = ctrl_w_s_map
        def ctrl_w_v_map(self):
            self.get_curr_tab().vsplit()
            return False
        self.maps[NORMAL][CTRL_W_KEY][ord('v')] = ctrl_w_v_map

        def ctrl_w_h_map(self):
            self.get_curr_tab().move_left_window()
            return False
        self.maps[NORMAL][CTRL_W_KEY][ord('h')] = ctrl_w_h_map
        self.maps[NORMAL][CTRL_W_KEY][CTRL_H_KEY] = ctrl_w_h_map
        def ctrl_w_j_map(self):
            self.get_curr_tab().move_down_window()
            return False
        self.maps[NORMAL][CTRL_W_KEY][ord('j')] = ctrl_w_j_map
        self.maps[NORMAL][CTRL_W_KEY][CTRL_J_KEY] = ctrl_w_j_map
        def ctrl_w_k_map(self):
            self.get_curr_tab().move_up_window()
            return False
        self.maps[NORMAL][CTRL_W_KEY][ord('k')] = ctrl_w_k_map
        self.maps[NORMAL][CTRL_W_KEY][CTRL_K_KEY] = ctrl_w_k_map
        def ctrl_w_l_map(self):
            self.get_curr_tab().move_right_window()
            return False
        self.maps[NORMAL][CTRL_W_KEY][ord('l')] = ctrl_w_l_map
        self.maps[NORMAL][CTRL_W_KEY][CTRL_L_KEY] = ctrl_w_l_map

    def _initialize_normal_ctrl_maps(self):
        def ctrl_u_map(self):
            self.get_curr_window().scroll_up_half_page()
            return False
        self.maps[NORMAL][CTRL_U_KEY] = ctrl_u_map
        def ctrl_d_map(self):
            self.get_curr_window().scroll_down_half_page()
            return False
        self.maps[NORMAL][CTRL_D_KEY] = ctrl_d_map
        def ctrl_l_map(self):
            self.get_curr_buffer().resync_treesitter()
            self.get_curr_tab().draw()
            return False
        self.maps[NORMAL][CTRL_L_KEY] = ctrl_l_map
        def ctrl_r_map(self):
            self.get_curr_window().redo()
            return False
        self.maps[NORMAL][CTRL_R_KEY] = ctrl_r_map

    def _initialize_normal_symbol_maps(self):
        def zero_map(self):
            self.get_curr_window().move_line_begin()
            return False
        self.maps[NORMAL][ord('0')] = zero_map
        def dollar_map(self):
            self.get_curr_window().move_line_end()
            return False
        self.maps[NORMAL][ord('$')] = dollar_map

    def _initialize_objects_maps(self, maps, cb):
        def move_(self): pass

        def move_j(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            # TODO: check boundries
            scope = (x, y, x, y + 1)
            if scope: return cb(scope)
        maps[ord('j')] = move_j
        def move_k(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            # TODO: check boundries
            scope = (x, y, x, y - 1)
            if scope: return cb(scope)
        maps[ord('k')] = move_k
        def move_h(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            # TODO: check boundries
            scope = (x, y, x - 1, y)
            if scope: return cb(scope)
        maps[ord('h')] = move_h
        def move_l(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            # TODO: check boundries
            scope = (x, y, x + 1, y)
            if scope: return cb(scope)
        maps[ord('l')] = move_l

        def move_w(self):
            start_x = self.get_curr_window().buffer_cursor[0]
            start_y = self.get_curr_window().buffer_cursor[1]
            ret = self.get_curr_buffer().find_next_word(start_x, start_y)
            if not ret: return False
            end_x, end_y = ret
            # scope = (start_x, start_y, end_x - 1, end_y)
            scope = (start_x, start_y, end_x, end_y)
            if scope: return cb(scope)
        maps[ord('w')] = move_w
        def move_W(self):
            start_x = self.get_curr_window().buffer_cursor[0]
            start_y = self.get_curr_window().buffer_cursor[1]
            ret = self.get_curr_buffer().find_next_WORD(start_x, start_y)
            if not ret: return False
            end_x, end_y = ret
            # scope = (start_x, start_y, end_x - 1, end_y)
            scope = (start_x, start_y, end_x, end_y)
            if scope: return cb(scope)
        maps[ord('W')] = move_W
        def move_b(self):
            end_x = self.get_curr_window().buffer_cursor[0] - 1
            end_y = self.get_curr_window().buffer_cursor[1]
            ret = self.get_curr_buffer().find_prev_word(end_x, end_y)
            if not ret: return False
            start_x, start_y = ret
            scope = (start_x, start_y, end_x, end_y)
            if scope: return cb(scope)
        maps[ord('b')] = move_b
        def move_B(self):
            end_x = self.get_curr_window().buffer_cursor[0] - 1
            end_y = self.get_curr_window().buffer_cursor[1]
            ret = self.get_curr_buffer().find_prev_WORD(end_x, end_y)
            if not ret: return False
            start_x, start_y = ret
            scope = (start_x, start_y, end_x, end_y)
            if scope: return cb(scope)
        maps[ord('B')] = move_B
        def move_e(self):
            start_x = self.get_curr_window().buffer_cursor[0]
            start_y = self.get_curr_window().buffer_cursor[1]
            ret = self.get_curr_buffer().find_word_end(start_x, start_y)
            if not ret: return False
            end_x, end_y = ret
            scope = (start_x, start_y, end_x, end_y)
            if scope: return cb(scope)
        maps[ord('e')] = move_e
        def move_E(self):
            start_x = self.get_curr_window().buffer_cursor[0]
            start_y = self.get_curr_window().buffer_cursor[1]
            ret = self.get_curr_buffer().find_WORD_end(start_x, start_y)
            if not ret: return False
            end_x, end_y = ret
            scope = (start_x, start_y, end_x, end_y)
            if scope: return cb(scope)
        maps[ord('E')] = move_E

        def ctrl_u_map(self):
            start_x = self.get_curr_window().buffer_cursor[0]
            start_y = self.get_curr_window().buffer_cursor[1]
            end_x, end_y = self.get_curr_window().half_page_up()
            scope = (start_x, start_y, end_x, end_y)
            if scope: return cb(scope)
            return False
        maps[CTRL_U_KEY] = ctrl_u_map
        def ctrl_d_map(self):
            start_x = self.get_curr_window().buffer_cursor[0]
            start_y = self.get_curr_window().buffer_cursor[1]
            end_x, end_y = self.get_curr_window().half_page_down()
            scope = (start_x, start_y, end_x, end_y)
            if scope: return cb(scope)
            return False
        maps[CTRL_D_KEY] = ctrl_d_map

        # def move_f(self):
            # start_x = self.get_curr_window().buffer_cursor[0]
            # start_y = self.get_curr_window().buffer_cursor[1]
            # ret = self.get_curr_buffer().find_WORD_end(x, y)
            # if not ret: return
            # end_x, end_y = ret
            # scope = (start_x, start_y, end_x, end_y)
            # if scope: cb(scope)
        # maps[ord('f')] = move_f
        # maps[ord('F')] = move_F
        # maps[ord('t')] = move_t
        # maps[ord('T')] = move_T

        maps[ord('g')] = {} # TODO
        maps[ord('g')][ord('g')] = move_ # TODO
        maps[ord('G')] = move_ # TODO

        # maps[ord('H')] = move_ # TODO
        # maps[ord('M')] = move_ # TODO
        # maps[ord('L')] = move_ # TODO

        # maps[ord('n')] = move_ # TODO
        # maps[ord('N')] = move_ # TODO

        maps[ord('i')] = {}
        def inner_parentheses(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_parentheses(x, y)
            if scope: return cb(scope)
        maps[ord('i')][ord('(')] = inner_parentheses
        maps[ord('i')][ord(')')] = inner_parentheses
        def inner_square_brackets(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_square_brackets(x, y)
            if scope: return cb(scope)
        maps[ord('i')][ord('[')] = inner_square_brackets
        maps[ord('i')][ord(']')] = inner_square_brackets
        def inner_curly_brackets(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_curly_brackets(x, y)
            if scope: return cb(scope)
        maps[ord('i')][ord('{')] = inner_curly_brackets
        maps[ord('i')][ord('}')] = inner_curly_brackets
        def inner_greater_than(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_greater_than(x, y)
            if scope: return cb(scope)
        maps[ord('i')][('<')] = inner_greater_than
        maps[ord('i')][('>')] = inner_greater_than
        def inner_quotation(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_quotation(x, y)
            if scope: return cb(scope)
        maps[ord('i')][ord('"')] = inner_quotation
        def inner_apostrophe(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_apostrophe(x, y)
            if scope: return cb(scope)
        maps[ord('i')][ord("'")] = inner_apostrophe
        def inner_backtick(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_backtick(x, y)
            if scope: return cb(scope)
        maps[ord('i')][ord("`")] = inner_backtick
        def inner_word(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_word(x, y)
            if scope: return cb(scope)
        maps[ord('i')][ord("w")] = inner_word
        def inner_WORD(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_WORD(x, y)
            if scope: return cb(scope)
        maps[ord('i')][ord("W")] = inner_WORD

        maps[ord('a')] = {}
        def arround_parentheses(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_parentheses(x, y)
            if scope: return cb(scope)
        maps[ord('a')][ord('(')] = arround_parentheses
        maps[ord('a')][ord(')')] = arround_parentheses
        def arround_square_brackets(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_square_brackets(x, y)
            if scope: return cb(scope)
        maps[ord('a')][ord('[')] = arround_square_brackets
        maps[ord('a')][ord(']')] = arround_square_brackets
        def arround_curly_brackets(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_curly_brackets(x, y)
            if scope: return cb(scope)
        maps[ord('a')][ord('{')] = arround_curly_brackets
        maps[ord('a')][ord('}')] = arround_curly_brackets
        def arround_greater_than(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_greater_than(x, y)
            if scope: return cb(scope)
        maps[ord('a')][ord('<')] = arround_greater_than
        maps[ord('a')][ord('>')] = arround_greater_than
        def arround_quotation(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_quotation(x, y)
            if scope: return cb(scope)
        maps[ord('a')][ord('"')] = arround_quotation
        def arround_apostrophe(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_apostrophe(x, y)
            if scope: return cb(scope)
        maps[ord('a')][ord("'")] = arround_apostrophe
        def arround_backtick(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_backtick(x, y)
            if scope: return cb(scope)
        maps[ord('a')][ord("`")] = arround_backtick
        def arround_word(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_word(x, y)
            if scope: return cb(scope)
        maps[ord('a')][ord("w")] = arround_word
        def arround_WORD(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_WORD(x, y)
            if scope: return cb(scope)
        maps[ord('a')][ord("W")] = arround_WORD

    def _initialize_normal_mainstream_maps(self):
        self.maps[NORMAL][ord('c')] = {}    # change
        self.maps[NORMAL][ord('d')] = {}    # delete
        self.maps[NORMAL][ord('y')] = {}    # yank
        self.maps[NORMAL][ord('g')] = {}    # go

        def change_object_map(scope): 
            start_x, start_y, end_x, end_y = scope
            self.get_curr_window().change_begin()
            self.get_curr_window().remove_scope(start_x, start_y, end_x, end_y)
            self.get_curr_window().change_end()
            self.change_mode(INSERT)
            return False
        self._initialize_objects_maps(self.maps[NORMAL][ord('c')], change_object_map)
        def delete_object_map(scope): 
            start_x, start_y, end_x, end_y = scope
            self.get_curr_window().change_begin()
            self.get_curr_window().remove_scope(start_x, start_y, end_x, end_y)
            self.get_curr_window().change_end()
            return False
        self._initialize_objects_maps(self.maps[NORMAL][ord('d')], delete_object_map)
        def yank_object_map(scope): 
            start_x, start_y, end_x, end_y = scope
            return False
        self._initialize_objects_maps(self.maps[NORMAL][ord('y')], yank_object_map)

        def yy_map(self):
            data = {}
            data["data"] = self.get_curr_window().get_curr_line()
            data["meta"] = "line" # to let the paste know the data is entire line.
            self.registers['"'] = data
            return False
        self.maps[NORMAL][ord('y')][ord('y')] = yy_map
        def dd_map(self):
            self.get_curr_window().change_begin()

            data = {}
            data["data"] = self.get_curr_window().get_curr_line()
            data["meta"] = "line" # to let the paste know the data is entire line.
            self.registers['"'] = data

            self.get_curr_window().remove_line()
            self.get_curr_window().change_end()
            return False
        self.maps[NORMAL][ord('d')][ord('d')] = dd_map
        def gg_map(self):
            self.get_curr_window().move_begin()
            return False
        self.maps[NORMAL][ord('g')][ord('g')] = gg_map
        def G_map(self):
            self.get_curr_window().move_end()
            return False
        self.maps[NORMAL][ord('G')] = G_map
        def w_map(self):
            self.get_curr_window().move_word_forward()
            return False
        self.maps[NORMAL][ord('w')] = w_map
        def W_map(self):
            self.get_curr_window().move_WORD_forward()
            return False
        self.maps[NORMAL][ord('W')] = W_map
        def b_map(self):
            self.get_curr_window().move_word_backward()
            return False
        self.maps[NORMAL][ord('b')] = b_map
        def B_map(self):
            self.get_curr_window().move_WORD_backward()
            return False
        self.maps[NORMAL][ord('B')] = B_map
        def e_map(self):
            self.get_curr_window().move_word_end()
            return False
        self.maps[NORMAL][ord('e')] = e_map
        def E_map(self):
            self.get_curr_window().move_WORD_end()
            return False
        self.maps[NORMAL][ord('E')] = E_map
        def f_map(self):
            self.get_curr_window().find()
            return False
        self.maps[NORMAL][ord('f')] = f_map
        def F_map(self):
            self.get_curr_window().find_back()
            return False
        self.maps[NORMAL][ord('F')] = F_map
        def t_map(self):
            self.get_curr_window().till()
            return False
        self.maps[NORMAL][ord('t')] = t_map
        def T_map(self):
            self.get_curr_window().till_back()
            return False
        self.maps[NORMAL][ord('T')] = T_map
        def H_map(self):
            self.get_curr_window().move_begin_visible()
            return False
        self.maps[NORMAL][ord('H')] = H_map
        def M_map(self):
            self.get_curr_window().move_middle_visible()
            return False
        self.maps[NORMAL][ord('M')] = M_map
        def L_map(self):
            self.get_curr_window().move_end_visible()
            return False
        self.maps[NORMAL][ord('L')] = L_map
        def o_map(self):
            self.change_mode(INSERT)
            self.get_curr_window().new_line_after()
            return False
        self.maps[NORMAL][ord('o')] = o_map
        def O_map(self):
            self.change_mode(INSERT)
            self.get_curr_window().new_line_before()
            return False
        self.maps[NORMAL][ord('O')] = O_map
        def A_map(self):
            self.change_mode(INSERT)
            self.get_curr_window().move_line_end()
            return False
        self.maps[NORMAL][ord('A')] = A_map
        def a_map(self):
            self.change_mode(INSERT)
            self.get_curr_window().move_right()
            return False
        self.maps[NORMAL][ord('a')] = a_map
        def I_map(self):
            self.change_mode(INSERT)
            self.get_curr_window().move_line_begin(ignore_spaces=True)
            return False
        self.maps[NORMAL][ord('I')] = I_map
        def i_map(self):
            self.change_mode(INSERT)
            return False
        self.maps[NORMAL][ord('i')] = i_map
        def X_map(self):
            self.get_curr_window().change_begin()
            self.get_curr_window().remove_char_special(self.get_curr_window().buffer_cursor[0])
            self.get_curr_window().change_end()
            return False
        self.maps[NORMAL][ord('X')] = X_map
        def x_map(self):
            self.get_curr_window().change_begin()
            self.get_curr_window().remove_char_special(self.get_curr_window().buffer_cursor[0] + 1)
            self.get_curr_window().change_end()
            return False
        self.maps[NORMAL][ord('x')] = x_map
        def P_map(self):
            self.get_curr_window().change_begin()
            data = self.registers['"']
            if data:
                if data['meta'] == 'line':
                    line = data['data']
                    self.get_curr_window().insert_line_before(line)
                elif data['meta'] == 'char': pass
                elif data['meta'] == 'block': pass
            self.get_curr_window().change_end()
            return False
        self.maps[NORMAL][ord('P')] = P_map
        def p_map(self):
            self.get_curr_window().change_begin()
            data = self.registers['"']
            if data:
                if data['meta'] == 'line':
                    line = data['data']
                    self.get_curr_window().insert_line_after(line)
                elif data['meta'] == 'char': pass
                elif data['meta'] == 'block': pass
            self.get_curr_window().change_end()
            return False
        self.maps[NORMAL][ord('p')] = p_map
        def u_map(self):
            self.get_curr_window().undo()
            return False
        self.maps[NORMAL][ord('u')] = u_map
        def V_map(self):
            self.change_mode(VISUAL_LINE)
            return False
        self.maps[NORMAL][ord('V')] = V_map
        def v_map(self):
            self.change_mode(VISUAL)
            return False
        self.maps[NORMAL][ord('v')] = v_map

        self.maps[NORMAL][ord('z')] = {}
        def zz_map(self):
            self.get_curr_window().align_center()
            return False
        self.maps[NORMAL][ord('z')][ord('z')] = zz_map
        def zb_map(self):
            self.get_curr_window().align_bottom()
            return False
        self.maps[NORMAL][ord('z')][ord('b')] = zb_map
        def zt_map(self):
            self.get_curr_window().align_top()
            return False
        self.maps[NORMAL][ord('z')][ord('t')] = zt_map

        self._initialize_normal_ctrl_maps()
        self._initialize_normal_symbol_maps()

    def _initialize_normal_maps(self):
        def colon_map(self):
            return self.on_command()
        self.maps[NORMAL][ord(':')] = colon_map

        def enter_map(self):
            enter_map.toggle = not enter_map.toggle
            if enter_map.toggle:
                self.get_curr_window().enable_lines_numbers()
            else:
                self.get_curr_window().disable_lines_numbers()
            return False
        enter_map.toggle = False
        self.maps[NORMAL][ENTER_KEY] = enter_map

        self._initialize_legends_maps(NORMAL)
        self._initialize_normal_mainstream_maps()
        self._initialize_normal_window_maps()

    def _initialize_insert_ctrl_maps(self):
        def ctrl_w_map(self):
            window = self.get_curr_window()

            start_x, start_y = window.buffer_cursor[0] - 1, window.buffer_cursor[1]

            ret = window.buffer.find_prev_word(start_x, start_y)
            if not ret: return
            end_x, end_y = ret

            window.remove_scope(start_x, start_y, end_x, end_y)
            return False
        self.maps[INSERT][CTRL_W_KEY] = ctrl_w_map

    def _initialize_insert_maps(self):
        self._initialize_insert_ctrl_maps()

    def _initialize_visual_line_maps(self): 
        def visual_line_object_map(scope): 
            start_x, start_y, end_x, end_y = scope
            # scope was just a movement
            if  start_x == self.get_curr_window().buffer_cursor[0] and \
                start_y == self.get_curr_window().buffer_cursor[1]:
                self.get_curr_buffer().visual_set_current(end_x, end_y)
            # scope was an object
            else:
                self.get_curr_buffer().visual_set_scope(start_x, start_y, end_x, end_y)

            self.get_curr_window().move_cursor_to_buf_location(end_x, end_y)
            self.draw()
            return False
        self._initialize_objects_maps(self.maps[VISUAL_LINE], visual_line_object_map)
        def d_map(self):
            scope = self.get_curr_buffer().visual_get_scope()
            if not scope: return False
            self.get_curr_window().change_begin()

            start_x, start_y, end_x, end_y = scope

            # data = {}
            # data["data"] = self.get_curr_window().get_curr_line()
            # data["meta"] = "scope" # to let the paste know the data is entire line.
            # self.registers['"'] = data
            for y in range(end_y, start_y - 1, -1):
                self.get_curr_window().remove_line_at(y)
            self.get_curr_window().change_end()
            self.change_mode(NORMAL)
            return False
        self.maps[VISUAL_LINE][ord('d')] = d_map

    def _initialize_visual_maps(self): 
        def visual_object_map(scope): 
            start_x, start_y, end_x, end_y = scope
            # scope was just a movement
            if  start_x == self.get_curr_window().buffer_cursor[0] and \
                start_y == self.get_curr_window().buffer_cursor[1]:
                self.get_curr_buffer().visual_set_current(end_x, end_y)
            # scope was an object
            else:
                self.get_curr_buffer().visual_set_scope(start_x, start_y, end_x, end_y)

            self.get_curr_window().move_cursor_to_buf_location(end_x, end_y)
            self.draw()
            return False
        self._initialize_objects_maps(self.maps[VISUAL], visual_object_map)
        def d_map(self):
            scope = self.get_curr_buffer().visual_get_scope()
            if not scope: return False
            self.get_curr_window().change_begin()

            start_x, start_y, end_x, end_y = scope

            # data = {}
            # data["data"] = self.get_curr_window().get_curr_line()
            # data["meta"] = "scope" # to let the paste know the data is entire line.
            # self.registers['"'] = data

            self.get_curr_window().remove_scope(start_x, start_y, end_x, end_y)
            self.get_curr_window().change_end()
            self.change_mode(NORMAL)
            return False
        self.maps[VISUAL][ord('d')] = d_map

    def initialize_maps(self):
        self._initialize_normal_maps()
        self._initialize_insert_maps()
        self._initialize_visual_maps()
        self._initialize_visual_line_maps()

    def initialize_registers(self):
        # we dont add all of vim's registers for now..

        # named registers
        for char in "abcdefghijklmnopqrstuvwxyz": self.registers[char] = None
        for char in "ABCDEFGHIJKLMNOPQRSTUVWXYZ": self.registers[char] = None
        # numbered registers
        for num in "0123456789": self.registers[num] = None
        # unamed register
        self.registers['"'] = None
        # last search pattern register
        self.registers['/'] = None

    def __init__(self, screen):
        self.screen = screen

        self.height, self.width = screen.get_height(), screen.get_width()

        self.registers = {}
        self.initialize_registers()

        self.maps = {}
        self.maps[NORMAL] = {}
        self.maps[INSERT] = {}
        self.maps[VISUAL] = {}
        self.maps[VISUAL_LINE] = {}
        self.maps[VISUAL_BLOCK] = {}
        self.maps[REPLACE] = {}

        self.mode = NORMAL # start in normal mode

        self.initialize_maps()

        self.tabs = []
        self.windows = []
        self.buffers = []

        self.curr_tab = -1

        # Register to global events!
        Hooks.register(ON_BUFFER_CREATE_AFTER, self.on_buffer_create_after_callback)
        Hooks.register(ON_BUFFER_DESTROY_AFTER, self.on_buffer_destroy_after_callback)

    def _create_tab(self, buffer=None):
        self.tabs.append(Tab(self.screen, self.width, self.height, buffer))
        self.curr_tab = len(self.tabs) - 1

        # Tell movim to draw the newly created tab
        Hooks.execute(ON_DRAW_TAB, None)

        return self.tabs[-1]

    def get_curr_tab(self):
        return self.tabs[self.curr_tab]
    def get_curr_window(self):
        return self.get_curr_tab().get_curr_window()
    def get_curr_buffer(self):
        return self.get_curr_window().buffer

    def bootstrap(self):
        global args

        if not args.filename:
            raise Exception("No files provided.")

        elog(f"EDITOR: {args.filename}")

        if not os.path.isfile(args.filename[0]):
            raise Exception("No files provided.")
        file = args.filename[0]

        buffer = Buffer(file)
        tab = self._create_tab(buffer)

    def screen_resize_handler(self, signum, frame):
        # curses.endwin()
        # curses.initscr()
        # self.height, self.width = self.stdscr.getmaxyx()
        self.height, self.width = 0,0 # TODO

        Hooks.execute(ON_RESIZE, (self.width, self.height))

    def _quit_command(self):
        tab = self.get_curr_tab()

        if len(tab.windows) == 1:
            return True
        
        window = tab.get_curr_window()
        tab.close_window(window)
        return False

    def exec_command(self, command):
        if command == 'q': 
            return self._quit_command()
        if command == 'w': 
            self.get_curr_window().buffer.write()
        if command == 'qa': 
            return True
        return False

    def draw_command(self, command):
        command_position = [0, 0]

        command_position[1] = int(self.height - 1)
        command_length = self.width - 1
        

        cmd = f":{command}"
        self.screen.write(  command_position[1], 
                            command_position[0],
                            cmd.ljust(command_length))
        self.screen.move_cursor(    command_position[1],
                                    command_position[0] + len(cmd))

    def on_insert(self, key):
        ret = False

        if key == BACKSPACE_KEY:
            line = self.get_curr_window().get_curr_line()
            x = self.get_curr_window().buffer_cursor[0]
            if line[x-4:x] == '    ':
                self.get_curr_window().remove_chars(4)
            else:
                self.get_curr_window().remove_char()

            return ret

        if key == TAB_KEY:
            # expand tab to spaces
            self.get_curr_window().insert_string("    ")
            return ret

        try: 
            char = chr(key)
            elog(f"INSERT: ({key}) -> {char}")
            if char in printable:
                self.get_curr_window().insert_char(char)
            else:
                elog(f"INSERT: ({key}) not printable.")
        except Exception as e: elog(f"Exception: {e}")
        return ret

    def on_command(self):
        ret = False
        command = ""
        self.draw_command(command)
        while True:
            key = self.screen.get_key()

            if key == ESC_KEY: break
            if key == BACKSPACE_KEY: command = command[:-1] 
            if key == ENTER_KEY: # enter
                ret = self.exec_command(command)
                break

            try: 
                char = chr(key)
                if re.match("[a-zA-Z 0-9-_()]", char): command += char
            except: pass
            self.draw_command(command)

        self.screen.clear()
        self.get_curr_tab().draw()
        return ret

    def on_key(self, key):
        if key == ESC_KEY:
            self.change_mode(NORMAL)
            return False

        if key in self.maps[self.mode]:
            curr = self.maps[self.mode]
            if callable(curr[key]): return curr[key](self)

            while key in curr and isinstance(curr[key], dict): 
                curr = curr[key]
                key = self.get_inner_key()

                if not key: break
                if key not in curr: break

            if key in curr: curr[key](self)
        elif self.mode == INSERT:
            return self.on_insert(key)
        elif self.mode == NORMAL and \
            ord('1') <= key <= ord('9'):
            elog(f"EDITOR: key: {chr(key)}")
            return False

        return False


def main():
    global args

    parser = argparse.ArgumentParser()
    parser.add_argument('filename', nargs='+')
    args = parser.parse_args()

    screen = Screen()
    editor = Editor(screen)
    editor.bootstrap()

    k = 0
    while True:
        to_exit = editor.on_key(k)
        if to_exit: break

        k = screen.get_key()

    screen.clear()
    screen.move_cursor(0,0)


if __name__ == "__main__":
    main()
