#!/usr/bin/python3

from signal import signal, SIGWINCH
from string import printable
import timeout_decorator
import argparse
import curses
import time
import json
import re
import os

from settings import g_settings
from buffer import Buffer
from window import Window
from log import elog
from tab import Tab

from events import *
from hooks import *

args = None

NORMAL = 'normal'
INSERT = 'insert'
VISUAL = 'visual'
VISUAL_LINE = 'visual_line'
VISUAL_BLOCK = 'visual_block'
REPLACE = 'replace'
MAP_TIMEOOUT = 2 # in seconds

class Editor():
    def on_buffer_destroy_after_callback(self, buf): 
        self.buffers.remove(buf)

    def on_buffer_create_after_callback(self, buf): 
        self.buffers.append(buf)

    def draw(self):
        self.get_curr_tab().draw()
        pass

    @timeout_decorator.timeout(MAP_TIMEOOUT)
    def get_key_timeout(self):
        return self.stdscr.getch()

    def change_mode(self, target):
        if self.mode == INSERT and target == NORMAL:
            self.get_curr_window().change_end()
        if self.mode == NORMAL and target == INSERT:
            # in vim the transition from insert mode to normal mode causes the
            # cursor to move one index to the left. should I mimic this?
            self.get_curr_window().change_begin()

        self.mode = target

    def get_inner_key(self):
        try: return self.get_key_timeout()
        except: return None

    def initialize_theme(self):
        with open(self.config['theme_path'], 'r') as f: 
            self.theme = json.loads(f.read())

    def _initialize_legends_maps(self, mode):
        # Legends
        def j_map(self):
            self.get_curr_window().move_down()
            return False
        self.maps[mode][ord('j')] = j_map
        def k_map(self):
            self.get_curr_window().move_up()
            return False
        self.maps[mode][ord('k')] = k_map
        def l_map(self):
            self.get_curr_window().move_right()
            return False
        self.maps[mode][ord('l')] = l_map
        def h_map(self):
            self.get_curr_window().move_left()
            return False
        self.maps[mode][ord('h')] = h_map

    def _initialize_normal_ctrl_maps(self):
        def ctrl_u_map(self):
            self.get_curr_window().scroll_up_half_page()
            return False
        self.maps[NORMAL][21] = ctrl_u_map
        def ctrl_d_map(self):
            self.get_curr_window().scroll_down_half_page()
            return False
        self.maps[NORMAL][4] = ctrl_d_map
        def ctrl_l_map(self):
            self.get_curr_buffer().syntax.refresh()
            self.get_curr_window().draw()
            return False
        self.maps[NORMAL][12] = ctrl_l_map
        def ctrl_r_map(self):
            self.get_curr_window().redo()
            return False
        self.maps[NORMAL][18] = ctrl_r_map

    def _initialize_normal_symbol_maps(self):
        def zero_map(self):
            self.get_curr_window().move_line_begin()
            return False
        self.maps[NORMAL][ord('0')] = zero_map
        def dollar_map(self):
            self.get_curr_window().move_line_end()
            return False
        self.maps[NORMAL][ord('$')] = dollar_map

    def _initialize_objects_maps(self, maps, cb):
        def move_(self): pass

        def move_j(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = (x, y, x, y + 1)
            if scope: cb(scope)
        maps[ord('j')] = move_j
        def move_k(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = (x, y - 1, x, y)
            if scope: cb(scope)
        maps[ord('k')] = move_k
        def move_h(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = (x - 1, y, x, y)
            if scope: cb(scope)
        maps[ord('h')] = move_h
        def move_l(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = (x, y, x + 1, y)
            if scope: cb(scope)
        maps[ord('l')] = move_l

        def move_w(self):
            start_x = self.get_curr_window().buffer_cursor[0]
            start_y = self.get_curr_window().buffer_cursor[1]
            ret = self.get_curr_buffer().find_next_word(start_x, start_y)
            if not ret: return
            end_x, end_y = ret
            scope = (start_x, start_y, end_x - 1, end_y)
            if scope: cb(scope)
        maps[ord('w')] = move_w
        def move_W(self):
            start_x = self.get_curr_window().buffer_cursor[0]
            start_y = self.get_curr_window().buffer_cursor[1]
            ret = self.get_curr_buffer().find_next_WORD(start_x, start_y)
            if not ret: return
            end_x, end_y = ret
            scope = (start_x, start_y, end_x - 1, end_y)
            if scope: cb(scope)
        maps[ord('W')] = move_W
        def move_b(self):
            end_x = self.get_curr_window().buffer_cursor[0] - 1
            end_y = self.get_curr_window().buffer_cursor[1]
            ret = self.get_curr_buffer().find_prev_word(end_x, end_y)
            if not ret: return
            start_x, start_y = ret
            scope = (start_x, start_y, end_x, end_y)
            if scope: cb(scope)
        maps[ord('b')] = move_b
        def move_B(self):
            end_x = self.get_curr_window().buffer_cursor[0] - 1
            end_y = self.get_curr_window().buffer_cursor[1]
            ret = self.get_curr_buffer().find_prev_WORD(end_x, end_y)
            if not ret: return
            start_x, start_y = ret
            scope = (start_x, start_y, end_x, end_y)
            if scope: cb(scope)
        maps[ord('B')] = move_B
        def move_e(self):
            start_x = self.get_curr_window().buffer_cursor[0]
            start_y = self.get_curr_window().buffer_cursor[1]
            ret = self.get_curr_buffer().find_word_end(start_x, start_y)
            if not ret: return
            end_x, end_y = ret
            scope = (start_x, start_y, end_x, end_y)
            if scope: cb(scope)
        maps[ord('e')] = move_e
        def move_E(self):
            start_x = self.get_curr_window().buffer_cursor[0]
            start_y = self.get_curr_window().buffer_cursor[1]
            ret = self.get_curr_buffer().find_WORD_end(start_x, start_y)
            if not ret: return
            end_x, end_y = ret
            scope = (start_x, start_y, end_x, end_y)
            if scope: cb(scope)
        maps[ord('E')] = move_E

        # def move_f(self):
            # start_x = self.get_curr_window().buffer_cursor[0]
            # start_y = self.get_curr_window().buffer_cursor[1]
            # ret = self.get_curr_buffer().find_WORD_end(x, y)
            # if not ret: return
            # end_x, end_y = ret
            # scope = (start_x, start_y, end_x, end_y)
            # if scope: cb(scope)
        # maps[ord('f')] = move_f
        # maps[ord('F')] = move_F
        # maps[ord('t')] = move_t
        # maps[ord('T')] = move_T

        maps[ord('g')] = {} # TODO
        maps[ord('g')][ord('g')] = move_ # TODO
        maps[ord('G')] = move_ # TODO

        # maps[ord('H')] = move_ # TODO
        # maps[ord('M')] = move_ # TODO
        # maps[ord('L')] = move_ # TODO

        # maps[ord('n')] = move_ # TODO
        # maps[ord('N')] = move_ # TODO

        maps[ord('i')] = {}
        def inner_parentheses(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_parentheses(x, y)
            if scope: cb(scope)
        maps[ord('i')][ord('(')] = inner_parentheses
        maps[ord('i')][ord(')')] = inner_parentheses
        def inner_square_brackets(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_square_brackets(x, y)
            if scope: cb(scope)
        maps[ord('i')][ord('[')] = inner_square_brackets
        maps[ord('i')][ord(']')] = inner_square_brackets
        def inner_curly_brackets(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_curly_brackets(x, y)
            if scope: cb(scope)
        maps[ord('i')][ord('{')] = inner_curly_brackets
        maps[ord('i')][ord('}')] = inner_curly_brackets
        def inner_greater_than(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_greater_than(x, y)
            if scope: cb(scope)
        maps[ord('i')][('<')] = inner_greater_than
        maps[ord('i')][('>')] = inner_greater_than
        def inner_quotation(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_quotation(x, y)
            if scope: cb(scope)
        maps[ord('i')][ord('"')] = inner_quotation
        def inner_apostrophe(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_apostrophe(x, y)
            if scope: cb(scope)
        maps[ord('i')][ord("'")] = inner_apostrophe
        def inner_backtick(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_backtick(x, y)
            if scope: cb(scope)
        maps[ord('i')][ord("`")] = inner_backtick
        def inner_word(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_word(x, y)
            if scope: cb(scope)
        maps[ord('i')][ord("w")] = inner_word
        def inner_WORD(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_WORD(x, y)
            if scope: cb(scope)
        maps[ord('i')][ord("W")] = inner_WORD

        maps[ord('a')] = {}
        def arround_parentheses(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_parentheses(x, y)
            if scope: cb(scope)
        maps[ord('a')][ord('(')] = arround_parentheses
        maps[ord('a')][ord(')')] = arround_parentheses
        def arround_square_brackets(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_square_brackets(x, y)
            if scope: cb(scope)
        maps[ord('a')][ord('[')] = arround_square_brackets
        maps[ord('a')][ord(']')] = arround_square_brackets
        def arround_curly_brackets(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_curly_brackets(x, y)
            if scope: cb(scope)
        maps[ord('a')][ord('{')] = arround_curly_brackets
        maps[ord('a')][ord('}')] = arround_curly_brackets
        def arround_greater_than(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_greater_than(x, y)
            if scope: cb(scope)
        maps[ord('a')][ord('<')] = arround_greater_than
        maps[ord('a')][ord('>')] = arround_greater_than
        def arround_quotation(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_quotation(x, y)
            if scope: cb(scope)
        maps[ord('a')][ord('"')] = arround_quotation
        def arround_apostrophe(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_apostrophe(x, y)
            if scope: cb(scope)
        maps[ord('a')][ord("'")] = arround_apostrophe
        def arround_backtick(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_backtick(x, y)
            if scope: cb(scope)
        maps[ord('a')][ord("`")] = arround_backtick
        def arround_word(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_word(x, y)
            if scope: cb(scope)
        maps[ord('a')][ord("w")] = arround_word
        def arround_WORD(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_WORD(x, y)
            if scope: cb(scope)
        maps[ord('a')][ord("W")] = arround_WORD

    def _initialize_normal_mainstream_maps(self):
        self.maps[NORMAL][ord('c')] = {}    # change
        self.maps[NORMAL][ord('d')] = {}    # delete
        self.maps[NORMAL][ord('y')] = {}    # yank
        self.maps[NORMAL][ord('g')] = {}    # go

        def change_object_map(scope): 
            start_x, start_y, end_x, end_y = scope
            self.get_curr_window().change_begin()
            elog(f"EDITOR: change {scope}")
            self.get_curr_window().remove_scope(start_x, start_y, end_x, end_y)
            self.get_curr_window().change_end()
            self,change_mode(INSERT)
            return False
        self._initialize_objects_maps(self.maps[NORMAL][ord('c')], change_object_map)
        def delete_object_map(scope): 
            start_x, start_y, end_x, end_y = scope
            self.get_curr_window().change_begin()
            elog(f"EDITOR: delete {scope}")
            self.get_curr_window().remove_scope(start_x, start_y, end_x, end_y)
            self.get_curr_window().change_end()
            return False
        self._initialize_objects_maps(self.maps[NORMAL][ord('d')], delete_object_map)
        def yank_object_map(scope): 
            start_x, start_y, end_x, end_y = scope
            elog(f"EDITOR: yank {scope}")
            return False
        self._initialize_objects_maps(self.maps[NORMAL][ord('y')], yank_object_map)

        def yy_map(self):
            data = {}
            data["data"] = self.get_curr_window().get_curr_line()
            data["meta"] = "line" # to let the paste know the data is entire line.
            self.registers['"'] = data
            return False
        self.maps[NORMAL][ord('y')][ord('y')] = yy_map
        def dd_map(self):
            self.get_curr_window().change_begin()

            data = {}
            data["data"] = self.get_curr_window().get_curr_line()
            data["meta"] = "line" # to let the paste know the data is entire line.
            self.registers['"'] = data

            self.get_curr_window().remove_line()
            self.get_curr_window().change_end()
            return False
        self.maps[NORMAL][ord('d')][ord('d')] = dd_map
        def gg_map(self):
            self.get_curr_window().move_begin()
            return False
        self.maps[NORMAL][ord('g')][ord('g')] = gg_map
        def G_map(self):
            self.get_curr_window().move_end()
            return False
        self.maps[NORMAL][ord('G')] = G_map
        def w_map(self):
            self.get_curr_window().move_word_forward()
            return False
        self.maps[NORMAL][ord('w')] = w_map
        def W_map(self):
            self.get_curr_window().move_WORD_forward()
            return False
        self.maps[NORMAL][ord('W')] = W_map
        def b_map(self):
            self.get_curr_window().move_word_backward()
            return False
        self.maps[NORMAL][ord('b')] = b_map
        def B_map(self):
            self.get_curr_window().move_WORD_backward()
            return False
        self.maps[NORMAL][ord('B')] = B_map
        def e_map(self):
            self.get_curr_window().move_word_end()
            return False
        self.maps[NORMAL][ord('e')] = e_map
        def E_map(self):
            self.get_curr_window().move_WORD_end()
            return False
        self.maps[NORMAL][ord('E')] = E_map
        def f_map(self):
            self.get_curr_window().find()
            return False
        self.maps[NORMAL][ord('f')] = f_map
        def F_map(self):
            self.get_curr_window().find_back()
            return False
        self.maps[NORMAL][ord('F')] = F_map
        def t_map(self):
            self.get_curr_window().till()
            return False
        self.maps[NORMAL][ord('t')] = t_map
        def T_map(self):
            self.get_curr_window().till_back()
            return False
        self.maps[NORMAL][ord('T')] = T_map
        def o_map(self):
            self.change_mode(INSERT)
            self.get_curr_window().new_line_after()
            return False
        self.maps[NORMAL][ord('o')] = o_map
        def O_map(self):
            self.change_mode(INSERT)
            self.get_curr_window().new_line_before()
            return False
        self.maps[NORMAL][ord('O')] = O_map
        def A_map(self):
            self.change_mode(INSERT)
            self.get_curr_window().move_line_end()
            return False
        self.maps[NORMAL][ord('A')] = A_map
        def a_map(self):
            self.change_mode(INSERT)
            self.get_curr_window().move_right()
            return False
        self.maps[NORMAL][ord('a')] = a_map
        def I_map(self):
            self.change_mode(INSERT)
            self.get_curr_window().move_line_begin()
            return False
        self.maps[NORMAL][ord('I')] = I_map
        def i_map(self):
            self.change_mode(INSERT)
            return False
        self.maps[NORMAL][ord('i')] = i_map
        def X_map(self):
            self.get_curr_window().change_begin()
            self.get_curr_window().remove_char_special(self.get_curr_window().buffer_cursor[0])
            self.get_curr_window().change_end()
            return False
        self.maps[NORMAL][ord('X')] = X_map
        def x_map(self):
            self.get_curr_window().change_begin()
            self.get_curr_window().remove_char_special(self.get_curr_window().buffer_cursor[0] + 1)
            self.get_curr_window().change_end()
            return False
        self.maps[NORMAL][ord('x')] = x_map
        def P_map(self):
            self.get_curr_window().change_begin()
            data = self.registers['"']
            if data:
                if data['meta'] == 'line':
                    line = data['data']
                    self.get_curr_window().insert_line_before(line)
                elif data['meta'] == 'char': pass
                elif data['meta'] == 'block': pass
            self.get_curr_window().change_end()
            return False
        self.maps[NORMAL][ord('P')] = P_map
        def p_map(self):
            self.get_curr_window().change_begin()
            data = self.registers['"']
            if data:
                if data['meta'] == 'line':
                    line = data['data']
                    self.get_curr_window().insert_line_after(line)
                elif data['meta'] == 'char': pass
                elif data['meta'] == 'block': pass
            self.get_curr_window().change_end()
            return False
        self.maps[NORMAL][ord('p')] = p_map
        def u_map(self):
            self.get_curr_window().undo()
            return False
        self.maps[NORMAL][ord('u')] = u_map
        def V_map(self):
            self.change_mode(VISUAL_LINE)
            return False
        self.maps[NORMAL][ord('V')] = V_map
        def v_map(self):
            self.change_mode(VISUAL)
            return False
        self.maps[NORMAL][ord('v')] = v_map

        self._initialize_normal_ctrl_maps()
        self._initialize_normal_symbol_maps()

    def _initialize_normal_maps(self):
        def colon_map(self):
            return self.on_command()
        self.maps[NORMAL][ord(':')] = colon_map

        self._initialize_legends_maps(NORMAL)
        self._initialize_normal_mainstream_maps()

    def _initialize_insert_maps(self): pass

    def _initialize_visual_maps(self): 
        self._initialize_legends_maps(VISUAL)
        self._initialize_legends_maps(VISUAL_LINE)
        self._initialize_legends_maps(VISUAL_BLOCK)

    def initialize_maps(self):
        self._initialize_normal_maps()
        self._initialize_insert_maps()
        self._initialize_visual_maps()

    def initialize_registers(self):
        # we dont add all of vim's registers for now..

        # named registers
        for char in "abcdefghijklmnopqrstuvwxyz": self.registers[char] = None
        for char in "ABCDEFGHIJKLMNOPQRSTUVWXYZ": self.registers[char] = None
        # numbered registers
        for num in "0123456789": self.registers[num] = None
        # unamed register
        self.registers['"'] = None
        # last search pattern register
        self.registers['/'] = None

    def __init__(self, stdscr):
        self.stdscr = stdscr
        curses.start_color()
        # curses.use_default_colors()

        self.height, self.width = stdscr.getmaxyx()
        signal(SIGWINCH, self.screen_resize_handler)

        self.registers = {}
        self.initialize_registers()

        self.maps = {}
        self.maps[NORMAL] = {}
        self.maps[INSERT] = {}
        self.maps[VISUAL] = {}
        self.maps[VISUAL_LINE] = {}
        self.maps[VISUAL_BLOCK] = {}
        self.maps[REPLACE] = {}

        self.mode = NORMAL # start in normal mode

        self.initialize_maps()

        self.tabs = []
        self.windows = []
        self.buffers = []

        self.curr_tab = -1

        # Register to global events!
        Hooks.register(ON_BUFFER_CREATE_AFTER, self.on_buffer_create_after_callback)
        Hooks.register(ON_BUFFER_DESTROY_AFTER, self.on_buffer_destroy_after_callback)

    def _create_tab(self, buffer=None):
        self.tabs.append(Tab(self.stdscr, self.width, self.height, buffer))
        self.curr_tab = len(self.tabs) - 1

        # Tell movim to draw the newly created tab
        Hooks.execute(ON_DRAW_TAB, None)

        return self.tabs[-1]

    def get_curr_tab(self):
        return self.tabs[self.curr_tab]
    def get_curr_window(self):
        return self.get_curr_tab().get_curr_window()
    def get_curr_buffer(self):
        return self.get_curr_window().buffer

    def bootstrap(self):
        global args

        if not args.filename:
            raise Exception("No files provided.")

        elog(f"EDITOR: {args.filename}")

        if not os.path.isfile(args.filename[0]):
            raise Exception("No files provided.")
        file = args.filename[0]

        buffer = Buffer(file)
        tab = self._create_tab(buffer)

    def screen_resize_handler(self, signum, frame):
        curses.endwin()
        curses.initscr()
        self.height, self.width = self.stdscr.getmaxyx()

        Hooks.execute(ON_RESIZE, (self.width, self.height))

    def exec_command(self, command):
        if command == 'q': return True
        if command == 'w': 
            self.get_curr_window().buffer.write()
            pass
        return False

    def draw_command(self, command):
        command_position = [0, 0]

        command_position[1] = int(self.height - 1)
        command_length = self.width - 1
        

        cmd = f":{command}"
        self.stdscr.addstr( command_position[1], 
                            command_position[0],
                            cmd.ljust(command_length))
        self.stdscr.move(   command_position[1],
                            command_position[0] + len(cmd))

    def on_insert(self, key):
        ret = False

        if key == 263: # backslash
            self.get_curr_window().remove_char()
            return ret

        if key == 9: # tab
            # expand tab to spaces
            for i in range(4): self.get_curr_window().insert_char(' ')
            return ret

        try: 
            char = chr(key)
            if char in printable:
                self.get_curr_window().insert_char(char)
            else:
                elog(f"INSERT: ({key}) not printable.")
        except Exception as e: elog(f"Exception: {e}")
        return ret

    def on_command(self):
        ret = False
        command = ""
        self.draw_command(command)
        while True:
            self.stdscr.refresh() # refresh the screen
            key = self.stdscr.getch()

            if key == 27: break # esc
            if key == 263: command = command[:-1] # backslash
            if key == 10: # enter
                ret = self.exec_command(command)
                break
 
            try: elog(f"KEY: '{chr(key)}' -> ord({key}) -> {curses.keyname(key).decode()}")
            except Exception as e: elog(f"Exception: {e}")

            try: 
                char = chr(key)
                if re.match("[a-zA-Z 0-9-_()]", char): command += char
            except: pass
            self.draw_command(command)

        self.stdscr.refresh() # refresh the screen
        self.stdscr.clear()
        self.get_curr_tab().draw()
        return ret

    def on_key(self, key):
        try: elog(f"KEY: '{chr(key)}' -> ord({key}) -> {curses.keyname(key).decode()}")
        except Exception as e: pass

        if key == 27: # esc
            self.change_mode(NORMAL)
            return False

        if key in self.maps[self.mode]:
            curr = self.maps[self.mode]
            if callable(curr[key]): return curr[key](self)

            while key in curr and isinstance(curr[key], dict): 
                curr = curr[key]
                key = self.get_inner_key()

                if not key: break
                if key not in curr: break

            if key in curr: curr[key](self)

        if  self.mode == NORMAL and \
            ord('1') <= key <= ord('9'):
            elog(f"EDITOR: key: {chr(key)}")
            return False
            
        if self.mode == INSERT:
            return self.on_insert(key)

        return False


def _main(stdscr):
    editor = Editor(stdscr)

    stdscr.clear()

    editor.bootstrap()
    stdscr.refresh()

    k = 0
    while True:
        to_exit = editor.on_key(k)
        if to_exit: break

        stdscr.refresh() # refresh the screen
        k = stdscr.getch()

def main():
    global args

    parser = argparse.ArgumentParser()
    parser.add_argument('filename', nargs='+')
    args = parser.parse_args()

    # remove the delay for the esc key!
    os.environ.setdefault('ESCDELAY', '25') 

    curses.wrapper(_main)


if __name__ == "__main__":
    main()
