#!/usr/bin/python3

from signal import signal, SIGWINCH
from string import printable
import traceback
import argparse
import time
import json
import re
import os

from settings import get_settings, load_settings
from buffer import Buffer
from window import Window
from task import Task
from screen import *
from log import elog
from tab import Tab

from events import *
from hooks import *
from popup import *

from plugins import clipboard
from plugins import comment
from plugins import ripgrep
from plugins import format
from plugins import fzf

from utils import *

args = None

NORMAL = 'normal'
INSERT = 'insert'
VISUAL = 'visual'
VISUAL_LINE = 'visual_line'
VISUAL_BLOCK = 'visual_block'
REPLACE = 'replace'
MAP_TIMEOOUT = 2 # in seconds

class Editor():
    def on_buffer_destroy_after_callback(self, buf):
        self.buffers.remove(buf)

    def on_buffer_create_after_callback(self, buf):
        self.buffers.append(buf)

    def draw(self):
        self.get_curr_tab().draw()

    def change_begin(self):
        self.get_curr_window().change_begin()

    def change_end(self):
        self.get_curr_window().change_end()

        # set last change in '.' register for the repeat operation.
        self.registers["."] = self.internal_registers["."].copy()
        self.internal_registers["."] = []

    def change_mode(self, target, effect_change=True):
        if self.mode == INSERT and target == NORMAL:
            if effect_change: self.change_end()
            self.get_curr_window().move_left()
            self.screen.set_cursor_block_blink()
        if self.mode == NORMAL and target == INSERT:
            if effect_change: self.change_begin()
            self.screen.set_cursor_i_beam()
        if self.mode == NORMAL and target == VISUAL_LINE:
            self.get_curr_window().visual_begin(VISUAL_LINE)
        if self.mode == NORMAL and target == VISUAL:
            self.get_curr_window().visual_begin(VISUAL)
        if self.mode == VISUAL and target == NORMAL:
            self.get_curr_window().visual_end()
        if self.mode == VISUAL and target == INSERT:
            self.get_curr_window().visual_end()
        if self.mode == VISUAL_LINE and target == NORMAL:
            self.get_curr_window().visual_end()
        if self.mode == NORMAL and target == REPLACE:
            self.screen.set_cursor_underline()
            self.change_begin()
            self._replace_line = self.get_curr_window().get_curr_line()
            self._replace_x = self.get_curr_window().buffer_cursor[0]
            self._replace_y = self.get_curr_window().buffer_cursor[1]
        if self.mode == REPLACE and target == NORMAL:
            self.change_end()
            self.screen.set_cursor_block_blink()
            self._replace_line = ""
            self._replace_x = -1
            self._replace_y = -1

        self.mode = target
        self.curr_maps = self.maps[self.mode]

    def initialize_theme(self):
        with open(self.config['theme_path'], 'r') as f:
            self.theme = json.loads(f.read())

    def _initialize_legends_maps(self, mode):
        # Legends
        def j_map(self):
            num = 1
            if len(self._number) > 0:
                num = int(self._number)

            for _ in range(num):
                self.get_curr_window().move_down()
            return False
        self.maps[mode][ord('j')] = j_map
        def k_map(self):
            num = 1
            if len(self._number) > 0:
                num = int(self._number)

            for _ in range(num):
                self.get_curr_window().move_up()
            return False
        self.maps[mode][ord('k')] = k_map
        def l_map(self):
            self.get_curr_window().move_right()
            return False
        self.maps[mode][ord('l')] = l_map
        def h_map(self):
            self.get_curr_window().move_left()
            return False
        self.maps[mode][ord('h')] = h_map

    def _initialize_normal_window_maps(self):
        self.maps[NORMAL][CTRL_W_KEY] = {}
        def ctrl_w_s_map(self):
            self.get_curr_tab().split()
            return False
        self.maps[NORMAL][CTRL_W_KEY][ord('s')] = ctrl_w_s_map
        self.maps[NORMAL][CTRL_W_KEY][CTRL_S_KEY] = ctrl_w_s_map
        def ctrl_w_v_map(self):
            self.get_curr_tab().vsplit()
            return False
        self.maps[NORMAL][CTRL_W_KEY][ord('v')] = ctrl_w_v_map
        self.maps[NORMAL][CTRL_W_KEY][CTRL_V_KEY] = ctrl_w_v_map
        def ctrl_w_h_map(self):
            self.get_curr_tab().move_to_left_window()
            return False
        self.maps[NORMAL][CTRL_W_KEY][ord('h')] = ctrl_w_h_map
        self.maps[NORMAL][CTRL_W_KEY][CTRL_H_KEY] = ctrl_w_h_map
        def ctrl_w_j_map(self):
            self.get_curr_tab().move_to_down_window()
            return False
        self.maps[NORMAL][CTRL_W_KEY][ord('j')] = ctrl_w_j_map
        self.maps[NORMAL][CTRL_W_KEY][CTRL_J_KEY] = ctrl_w_j_map
        def ctrl_w_k_map(self):
            self.get_curr_tab().move_to_up_window()
            return False
        self.maps[NORMAL][CTRL_W_KEY][ord('k')] = ctrl_w_k_map
        self.maps[NORMAL][CTRL_W_KEY][CTRL_K_KEY] = ctrl_w_k_map
        def ctrl_w_l_map(self):
            self.get_curr_tab().move_to_right_window()
            return False
        self.maps[NORMAL][CTRL_W_KEY][ord('l')] = ctrl_w_l_map
        self.maps[NORMAL][CTRL_W_KEY][CTRL_L_KEY] = ctrl_w_l_map
        def ctrl_w_w_map(self):
            self.get_curr_tab().zoom_toggle()
            return False
        self.maps[NORMAL][CTRL_W_KEY][ord('w')] = ctrl_w_w_map
        self.maps[NORMAL][CTRL_W_KEY][CTRL_W_KEY] = ctrl_w_w_map
        def ctrl_w_t_map(self):
            self._create_tab(self.get_curr_buffer())
            return False
        self.maps[NORMAL][CTRL_W_KEY][ord('t')] = ctrl_w_t_map
        self.maps[NORMAL][CTRL_W_KEY][CTRL_T_KEY] = ctrl_w_t_map
        def ctrl_w_H_map(self):
            elog("ctrl_w_H_map")
            return False
        self.maps[NORMAL][CTRL_W_KEY][ord('H')] = ctrl_w_H_map
        def ctrl_w_J_map(self):
            elog("ctrl_w_J_map")
            return False
        self.maps[NORMAL][CTRL_W_KEY][ord('J')] = ctrl_w_J_map
        def ctrl_w_K_map(self):
            elog("ctrl_w_K_map")
            return False
        self.maps[NORMAL][CTRL_W_KEY][ord('K')] = ctrl_w_K_map
        def ctrl_w_L_map(self):
            elog("ctrl_w_L_map")
            return False
        self.maps[NORMAL][CTRL_W_KEY][ord('L')] = ctrl_w_L_map

    def _initialize_normal_ctrl_maps(self):
        def ctrl_u_map(self):
            self.get_curr_window().scroll_up_half_page()
            return False
        self.maps[NORMAL][CTRL_U_KEY] = ctrl_u_map
        def ctrl_d_map(self):
            self.get_curr_window().scroll_down_half_page()
            return False
        self.maps[NORMAL][CTRL_D_KEY] = ctrl_d_map
        def ctrl_l_map(self):
            self.get_curr_buffer().resync_treesitter()
            self.get_curr_tab().draw()
            return False
        self.maps[NORMAL][CTRL_L_KEY] = ctrl_l_map
        def ctrl_r_map(self):
            self.get_curr_window().redo()
            return False
        self.maps[NORMAL][CTRL_R_KEY] = ctrl_r_map
        def ctrl_i_map(self):
            jump = self.get_curr_window().next_jump()
            if not jump: return False
            if jump['file_path']:
                buffer = self.get_or_create_buffer(jump['file_path'])
                if self.get_curr_buffer().id != buffer.id:
                    self.get_curr_window().change_buffer(buffer)
            elif jump['buffer_id']:
                buffer = self.get_buffer_by_id(jump['buffer_id'])
                if not buffer: return False
                if self.get_curr_buffer().id != buffer.id:
                    self.get_curr_window().change_buffer(buffer)
            else:
                return False

            self.get_curr_window().move_cursor_to_buf_location( jump['col'],
                                                                jump['line'])
            self.get_curr_window().align_center()
            return False
        self.maps[NORMAL][CTRL_I_KEY] = ctrl_i_map
        def ctrl_o_map(self):
            jump = self.get_curr_window().prev_jump()
            if not jump: return False

            if jump['file_path']:
                buffer = self.get_or_create_buffer(jump['file_path'])
                if self.get_curr_buffer().id != buffer.id:
                    self.get_curr_window().change_buffer(buffer)
            elif jump['buffer_id']:
                buffer = self.get_buffer_by_id(jump['buffer_id'])
                if not buffer: return False
                if self.get_curr_buffer().id != buffer.id:
                    self.get_curr_window().change_buffer(buffer)
            else:
                return False

            self.get_curr_window().move_cursor_to_buf_location( jump['col'],
                                                                jump['line'])
            self.get_curr_window().align_center()

            return False
        self.maps[NORMAL][CTRL_O_KEY] = ctrl_o_map

        self.maps[NORMAL][CTRL_BACKSLASH_KEY] = {}
        def ctrl_backslash_c_map(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_buffer().inner_word(x, y)
            pattern = self.get_curr_buffer().get_scope_text(scope[0],
                                                            scope[1],
                                                            scope[2],
                                                            scope[3])
            if len(pattern) == 0: return False
            pattern = f"\\W{pattern[0]}\\("

            task = Task(ripgrep, pattern)
            self.tasks.append(task)
            def rg_on_done(results):
                if not results: return
                self.get_curr_tab().split(Buffer(data_in_bytes=results))

                # remove the task when done.
                self.tasks.remove(task)

            task.on_done(rg_on_done)
            task.start()
            return False
        self.maps[NORMAL][CTRL_BACKSLASH_KEY][ord('c')] = ctrl_backslash_c_map
        def ctrl_backslash_s_map(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_buffer().inner_word(x, y)
            pattern = self.get_curr_buffer().get_scope_text(scope[0],
                                                            scope[1],
                                                            scope[2],
                                                            scope[3])
            if len(pattern) == 0: return False
            pattern = f"\\W{pattern[0]}\\W"

            task = Task(ripgrep, pattern)
            self.tasks.append(task)
            def rg_on_done(results):
                if not results: return
                self.get_curr_tab().split(Buffer(data_in_bytes=results))

                # remove the task when done.
                self.tasks.remove(task)

            task.on_done(rg_on_done)
            task.start()
            return False
        self.maps[NORMAL][CTRL_BACKSLASH_KEY][ord('s')] = ctrl_backslash_s_map
        def ctrl_close_bracket_map(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_buffer().inner_word(x, y)
            pattern = self.get_curr_buffer().get_scope_text(scope[0],
                                                            scope[1],
                                                            scope[2],
                                                            scope[3])
            if len(pattern) == 0: return False
            # TODO: goto definition
            return False
        self.maps[NORMAL][CTRL_CLOSE_BRACKET_KEY] = ctrl_close_bracket_map

    def _initialize_normal_symbol_maps(self):
        def zero_map(self):
            self.get_curr_window().move_line_begin()
            return False
        self.maps[NORMAL][ord('0')] = zero_map
        def dollar_map(self):
            self.get_curr_window().move_line_end()
            return False
        self.maps[NORMAL][ord('$')] = dollar_map
        def slash_map(self):
            self.on_search(True)
            return False
        self.maps[NORMAL][ord('/')] = slash_map
        def question_mark_map(self):
            self.on_search(False)
            return False
        self.maps[NORMAL][ord('?')] = question_mark_map
        def tilda_map(self):
            self.change_begin()
            self.get_curr_window().upper()
            self.change_end()
            self.get_curr_window().move_right()
            return False
        self.maps[NORMAL][ord('~')] = tilda_map

    def __initialize_movement_objects_maps(self, maps, cb):
        def move_(self): pass
        def move_j(self):
            start_x = self.get_curr_window().buffer_cursor[0]
            start_y = self.get_curr_window().buffer_cursor[1]

            start_x = 0
            end_y = min(start_y + 1, len(self.get_curr_buffer().lines) - 1)
            end_x = len(self.get_curr_buffer().lines[end_y]) - 2

            scope = (start_x, start_y, end_x, end_y)
            if scope: return cb(scope)
        maps[ord('j')] = move_j
        def move_k(self):
            end_x = self.get_curr_window().buffer_cursor[0]
            end_y = self.get_curr_window().buffer_cursor[1]

            end_x = len(self.get_curr_buffer().lines[end_y]) - 2
            start_y = max(0, end_y - 1)
            start_x = 0

            scope = (start_x, start_y, end_x, end_y)
            if scope: return cb(scope)
        maps[ord('k')] = move_k
        def move_h(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            # TODO: check boundries
            scope = (x - 1, y, x - 1, y)
            if scope: return cb(scope)
        maps[ord('h')] = move_h
        def move_l(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            # TODO: check boundries
            scope = (x + 1, y, x + 1, y)
            if scope: return cb(scope)
        maps[ord('l')] = move_l

        def move_w(self):
            start_x = self.get_curr_window().buffer_cursor[0]
            start_y = self.get_curr_window().buffer_cursor[1]
            ret = self.get_curr_buffer().find_next_word(start_x, start_y)
            if not ret: return False
            end_x, end_y = ret
            if end_y > start_y:
                end_y = start_y
                end_x = len(self.get_curr_window().get_line(end_y)) - 1
            scope = (start_x, start_y, end_x - 1, end_y)
            if scope: return cb(scope)
        maps[ord('w')] = move_w
        def move_W(self):
            start_x = self.get_curr_window().buffer_cursor[0]
            start_y = self.get_curr_window().buffer_cursor[1]
            ret = self.get_curr_buffer().find_next_WORD(start_x, start_y)
            if not ret: return False
            end_x, end_y = ret
            if end_y > start_y:
                end_y = start_y
                end_x = len(self.get_curr_window().get_line(end_y)) - 1
            scope = (start_x, start_y, end_x - 1, end_y)
            if scope: return cb(scope)
        maps[ord('W')] = move_W
        def move_b(self):
            end_x = self.get_curr_window().buffer_cursor[0]
            end_y = self.get_curr_window().buffer_cursor[1]
            ret = self.get_curr_buffer().find_prev_word(end_x, end_y)
            if not ret: return False
            start_x, start_y = ret
            scope = (start_x, start_y, end_x - 1, end_y)
            if scope: return cb(scope)
        maps[ord('b')] = move_b
        def move_B(self):
            end_x = self.get_curr_window().buffer_cursor[0]
            end_y = self.get_curr_window().buffer_cursor[1]
            ret = self.get_curr_buffer().find_prev_WORD(end_x, end_y)
            if not ret: return False
            start_x, start_y = ret
            scope = (start_x, start_y, end_x - 1, end_y)
            if scope: return cb(scope)
        maps[ord('B')] = move_B
        def move_e(self):
            start_x = self.get_curr_window().buffer_cursor[0]
            start_y = self.get_curr_window().buffer_cursor[1]
            ret = self.get_curr_buffer().find_word_end(start_x, start_y)
            if not ret: return False
            end_x, end_y = ret
            scope = (start_x, start_y, end_x, end_y)
            if scope: return cb(scope)
        maps[ord('e')] = move_e
        def move_E(self):
            start_x = self.get_curr_window().buffer_cursor[0]
            start_y = self.get_curr_window().buffer_cursor[1]
            ret = self.get_curr_buffer().find_WORD_end(start_x, start_y)
            if not ret: return False
            end_x, end_y = ret
            scope = (start_x, start_y, end_x, end_y)
            if scope: return cb(scope)
        maps[ord('E')] = move_E

        def ctrl_u_map(self):
            start_x = self.get_curr_window().buffer_cursor[0]
            start_y = self.get_curr_window().buffer_cursor[1]
            end_x, end_y = self.get_curr_window().half_page_up()
            scope = (start_x, start_y, end_x, end_y)
            if scope: return cb(scope)
        maps[CTRL_U_KEY] = ctrl_u_map
        def ctrl_d_map(self):
            start_x = self.get_curr_window().buffer_cursor[0]
            start_y = self.get_curr_window().buffer_cursor[1]
            end_x, end_y = self.get_curr_window().half_page_down()
            scope = (start_x, start_y, end_x, end_y)
            if scope: return cb(scope)
        maps[CTRL_D_KEY] = ctrl_d_map

        def move_f_map(self):
            start_x = self.get_curr_window().buffer_cursor[0]
            start_y = self.get_curr_window().buffer_cursor[1]

            try:
                char = chr(self.screen.get_key())
                loc = self.get_curr_buffer().find_next_char(start_x,
                                                            start_y,
                                                            char)
                if not loc: return
                end_x, end_y = loc[0], loc[1]
                scope = (start_x, start_y, end_x, end_y)
                if scope: return cb(scope)
            except Exception as e: elog(f"{e}")
        maps[ord('f')] = move_f_map
        def move_F_map(self):
            end_x = self.get_curr_window().buffer_cursor[0]
            end_y = self.get_curr_window().buffer_cursor[1]

            try:
                char = chr(self.screen.get_key())
                loc = self.get_curr_buffer().find_prev_char(end_x,
                                                            end_y,
                                                            char)
                if not loc: return
                start_x, start_y = loc[0], loc[1]
                scope = (start_x, start_y, end_x, end_y)
                if scope: return cb(scope)
            except Exception as e: elog(f"{e}")
        maps[ord('F')] = move_F_map
        def move_t_map(self):
            start_x = self.get_curr_window().buffer_cursor[0]
            start_y = self.get_curr_window().buffer_cursor[1]

            try:
                char = chr(self.screen.get_key())
                loc = self.get_curr_buffer().find_next_char(start_x,
                                                            start_y,
                                                            char)
                if not loc: return
                end_x, end_y = loc[0], loc[1]
                end_x = end_x - 1 if end_x > 0 else end_x

                scope = (start_x, start_y, end_x, end_y)
                if scope: return cb(scope)
            except Exception as e: elog(f"{e}")
        maps[ord('t')] = move_t_map
        def move_T_map(self):
            end_x = self.get_curr_window().buffer_cursor[0]
            end_y = self.get_curr_window().buffer_cursor[1]

            try:
                char = chr(self.screen.get_key())
                loc = self.get_curr_buffer().find_prev_char(end_x,
                                                            end_y,
                                                            char)
                if not loc: return
                start_x, start_y = loc[0], loc[1]
                start_x = start_x + 1 if start_x < len(self.get_curr_window().get_line(start_y)) - 1 else start_x

                scope = (start_x, start_y, end_x, end_y)
                if scope: return cb(scope)
            except Exception as e: elog(f"{e}")
        maps[ord('T')] = move_T_map

        maps[ord('g')] = {} # TODO
        maps[ord('g')][ord('g')] = move_ # TODO
        maps[ord('G')] = move_ # TODO

        # maps[ord('H')] = move_ # TODO
        # maps[ord('M')] = move_ # TODO
        # maps[ord('L')] = move_ # TODO

        # maps[ord('n')] = move_ # TODO
        # maps[ord('N')] = move_ # TODO

    def __initialize_inner_around_objects_maps(self, maps, cb):
        maps[ord('i')] = {}
        def inner_parentheses(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_parentheses(x, y)
            if scope: return cb(scope)
        maps[ord('i')][ord('(')] = inner_parentheses
        maps[ord('i')][ord(')')] = inner_parentheses
        def inner_square_brackets(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_square_brackets(x, y)
            if scope: return cb(scope)
        maps[ord('i')][ord('[')] = inner_square_brackets
        maps[ord('i')][ord(']')] = inner_square_brackets
        def inner_curly_brackets(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_curly_brackets(x, y)
            if scope: return cb(scope)
        maps[ord('i')][ord('{')] = inner_curly_brackets
        maps[ord('i')][ord('}')] = inner_curly_brackets
        def inner_greater_than(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_greater_than(x, y)
            if scope: return cb(scope)
        maps[ord('i')][ord('<')] = inner_greater_than
        maps[ord('i')][ord('>')] = inner_greater_than
        def inner_quotation(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_quotation(x, y)
            if scope: return cb(scope)
        maps[ord('i')][ord('"')] = inner_quotation
        def inner_apostrophe(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_apostrophe(x, y)
            if scope: return cb(scope)
        maps[ord('i')][ord("'")] = inner_apostrophe
        def inner_backtick(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_backtick(x, y)
            if scope: return cb(scope)
        maps[ord('i')][ord("`")] = inner_backtick
        def inner_word(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_word(x, y)
            if scope: return cb(scope)
        maps[ord('i')][ord("w")] = inner_word
        def inner_WORD(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.inner_WORD(x, y)
            if scope: return cb(scope)
        maps[ord('i')][ord("W")] = inner_WORD

        maps[ord('a')] = {}
        def arround_parentheses(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_parentheses(x, y)
            if scope: return cb(scope)
        maps[ord('a')][ord('(')] = arround_parentheses
        maps[ord('a')][ord(')')] = arround_parentheses
        def arround_square_brackets(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_square_brackets(x, y)
            if scope: return cb(scope)
        maps[ord('a')][ord('[')] = arround_square_brackets
        maps[ord('a')][ord(']')] = arround_square_brackets
        def arround_curly_brackets(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_curly_brackets(x, y)
            if scope: return cb(scope)
        maps[ord('a')][ord('{')] = arround_curly_brackets
        maps[ord('a')][ord('}')] = arround_curly_brackets
        def arround_greater_than(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_greater_than(x, y)
            if scope: return cb(scope)
        maps[ord('a')][ord('<')] = arround_greater_than
        maps[ord('a')][ord('>')] = arround_greater_than
        def arround_quotation(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_quotation(x, y)
            if scope: return cb(scope)
        maps[ord('a')][ord('"')] = arround_quotation
        def arround_apostrophe(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_apostrophe(x, y)
            if scope: return cb(scope)
        maps[ord('a')][ord("'")] = arround_apostrophe
        def arround_backtick(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_backtick(x, y)
            if scope: return cb(scope)
        maps[ord('a')][ord("`")] = arround_backtick
        def arround_word(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_word(x, y)
            if scope: return cb(scope)
        maps[ord('a')][ord("w")] = arround_word
        def arround_WORD(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_window().buffer.arround_WORD(x, y)
            if scope: return cb(scope)
        maps[ord('a')][ord("W")] = arround_WORD

    def _initialize_objects_maps(self, maps, cb):
        self.__initialize_movement_objects_maps(maps, cb)
        self.__initialize_inner_around_objects_maps(maps, cb)

    def _initialize_normal_mainstream_maps(self):
        # operations
        self.maps[NORMAL][ord('c')] = {}    # change
        self.maps[NORMAL][ord('d')] = {}    # delete
        self.maps[NORMAL][ord('y')] = {}    # yank
        self.maps[NORMAL][ord('g')] = {}    # go
        self.maps[NORMAL][ord('>')] = {}    # indent right
        self.maps[NORMAL][ord('<')] = {}    # indent left

        def change_object_map(scope):
            start_x, start_y, end_x, end_y = scope
            self.change_begin()
            self.get_curr_window().remove_scope(start_x, start_y, end_x, end_y)
            self.change_mode(INSERT, effect_change=False)
            return False
        self._initialize_objects_maps(self.maps[NORMAL][ord('c')], change_object_map)
        # in the case of change, thw word movement is acting like the end movement.
        self.maps[NORMAL][ord('c')][ord('w')] = self.maps[NORMAL][ord('c')][ord('e')]
        def delete_object_map(scope):
            start_x, start_y, end_x, end_y = scope
            self.change_begin()
            self.get_curr_window().remove_scope(start_x, start_y, end_x, end_y)
            self.change_end()
            return False
        self._initialize_objects_maps(self.maps[NORMAL][ord('d')], delete_object_map)
        # in the case of delete, the j/k movements are acting like VISUAL_LINE
        # TODO: self.maps[NORMAL][ord('d')][ord('j')] =
        # TODO: self.maps[NORMAL][ord('d')][ord('k')] =
        def yank_object_map(scope):
            start_x, start_y, end_x, end_y = scope
            text = self.get_curr_buffer().get_scope_text(   start_x,
                                                            start_y,
                                                            end_x,
                                                            end_y)
            if len(text) == 0: return False

            # send yanked text to clipboard
            clipboard(text)

            data = {}
            data['meta'] = 'char'
            data['data'] = text
            self.registers['"'] = data
            return False
        self._initialize_objects_maps(self.maps[NORMAL][ord('y')], yank_object_map)
        def indent_right_object_map(scope):
            start_x, start_y, end_x, end_y = scope
            self.change_begin()
            self.get_curr_window().indent_lines(start_y, end_y, True)
            self.change_end()
            return False
        self._initialize_objects_maps(self.maps[NORMAL][ord('>')], indent_right_object_map)
        def indent_left_object_map(scope):
            start_x, start_y, end_x, end_y = scope
            self.change_begin()
            self.get_curr_window().indent_lines(start_y, end_y, False)
            self.change_end()
            return False
        self._initialize_objects_maps(self.maps[NORMAL][ord('<')], indent_left_object_map)

        def yy_map(self):
            data = {}
            text = [self.get_curr_window().get_curr_line()]

            # send yanked text to clipboard
            clipboard(text)

            data["data"] = text
            data["meta"] = "line" # to let the paste know the data is entire line.
            self.registers['"'] = data
            return False
        self.maps[NORMAL][ord('y')][ord('y')] = yy_map
        def dd_map(self):
            self.change_begin()

            data = {}
            data["data"] = [self.get_curr_window().get_curr_line()]
            data["meta"] = "line" # to let the paste know the data is entire line.
            self.registers['"'] = data

            self.get_curr_window().remove_line()
            self.change_end()
            return False
        self.maps[NORMAL][ord('d')][ord('d')] = dd_map
        def cc_map(self):
            self.change_begin()

            data = {}
            data["data"] = self.get_curr_window().get_curr_line()
            data["meta"] = "line" # to let the paste know the data is entire line.
            self.registers['"'] = data

            self.get_curr_window().empty_line()
            self.change_mode(INSERT, effect_change=False)
            return False
        self.maps[NORMAL][ord('c')][ord('c')] = cc_map
        def gt_gt_map(self):
            y = self.get_curr_window().buffer_cursor[1]
            self.change_begin()
            self.get_curr_window().indent_lines(y, y, True)
            self.change_end()
            return False
        self.maps[NORMAL][ord('>')][ord('>')] = gt_gt_map
        def lt_lt_map(self):
            y = self.get_curr_window().buffer_cursor[1]
            self.change_begin()
            self.get_curr_window().indent_lines(y, y, False)
            self.change_end()
            return False
        self.maps[NORMAL][ord('<')][ord('<')] = lt_lt_map
        def gT_map(self):
            self.prev_tab()
            return False
        self.maps[NORMAL][ord('g')][ord('T')] = gT_map
        def gt_map(self):
            self.next_tab()
            return False
        self.maps[NORMAL][ord('g')][ord('t')] = gt_map
        def gf_map(self):
            line = self.get_curr_window().get_curr_line()
            line = line[self.get_curr_window().buffer_cursor[0]:]
            file_path, file_line, file_col = extract_destination(line)
            if not file_path: return False

            buffer = self.get_or_create_buffer(file_path)
            self.get_curr_window().add_jump()
            self.get_curr_window().change_buffer(buffer)
            self.get_curr_window().move_cursor_to_buf_location(file_col, file_line)
            self.get_curr_window().add_jump()
            self.get_curr_window().align_center()
            return False
        self.maps[NORMAL][ord('g')][ord('f')] = gf_map
        def gg_map(self):
            self.get_curr_window().add_jump()
            self.get_curr_window().move_begin()
            self.get_curr_window().add_jump()
            return False
        self.maps[NORMAL][ord('g')][ord('g')] = gg_map
        def comment_object_map(scope):
            start_x, start_y, end_x, end_y = scope
            self.change_begin()

            try:
                comment(self, start_y, end_y)
            except Exception as e:
                elog(f"Exception: {e}")

            self.change_end()
            return False
        self.maps[NORMAL][ord('g')][ord('c')] = {}
        self._initialize_objects_maps(self.maps[NORMAL][ord('g')][ord('c')], comment_object_map)
        def G_map(self):
            self.get_curr_window().add_jump()
            self.get_curr_window().move_end()
            self.get_curr_window().add_jump()
            return False
        self.maps[NORMAL][ord('G')] = G_map
        def w_map(self):
            self.get_curr_window().move_word_forward()
            return False
        self.maps[NORMAL][ord('w')] = w_map
        def W_map(self):
            self.get_curr_window().move_WORD_forward()
            return False
        self.maps[NORMAL][ord('W')] = W_map
        def b_map(self):
            self.get_curr_window().move_word_backward()
            return False
        self.maps[NORMAL][ord('b')] = b_map
        def B_map(self):
            self.get_curr_window().move_WORD_backward()
            return False
        self.maps[NORMAL][ord('B')] = B_map
        def e_map(self):
            self.get_curr_window().move_word_end()
            return False
        self.maps[NORMAL][ord('e')] = e_map
        def E_map(self):
            self.get_curr_window().move_WORD_end()
            return False
        self.maps[NORMAL][ord('E')] = E_map
        def f_map(self):
            char = self.get_curr_window().find()
            self._action = 'f'
            self._char = char
            return False
        self.maps[NORMAL][ord('f')] = f_map
        def F_map(self):
            char = self.get_curr_window().find_back()
            self._action = 'F'
            self._char = char
            return False
        self.maps[NORMAL][ord('F')] = F_map
        def t_map(self):
            char = self.get_curr_window().till()
            self._action = 't'
            self._char = char
            return False
        self.maps[NORMAL][ord('t')] = t_map
        def T_map(self):
            char = self.get_curr_window().till_back()
            self._dir = 'backward'
            self._char = char
            return False
        self.maps[NORMAL][ord('T')] = T_map
        def semicolon_map(self):
            if self._action == 'f':
                self.get_curr_window()._find(self._char)
            if self._action == 'F':
                self.get_curr_window()._find_back(self._char)
            if self._action == 't':
                self.get_curr_window()._till(self._char)
            if self._action == 'T':
                self.get_curr_window()._till_back(self._char)
            return False
        self.maps[NORMAL][ord(';')] = semicolon_map
        def comma_map(self):
            if self._action == 'f':
                self.get_curr_window()._find_back(self._char)
            if self._action == 'F':
                self.get_curr_window()._find(self._char)
            if self._action == 't':
                self.get_curr_window()._till_back(self._char)
            if self._action == 'T':
                self.get_curr_window()._till(self._char)
            return False
        self.maps[NORMAL][ord(',')] = comma_map
        def hash_map(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_buffer().inner_word(x, y)
            pattern = self.get_curr_buffer().get_scope_text(scope[0],
                                                            scope[1],
                                                            scope[2],
                                                            scope[3])
            if len(pattern) == 0: return False
            pattern = pattern[0]
            self.registers['/'] = pattern
            self._search_forward = False
            self._on_search(x, y, pattern, self._search_forward)
            return False
        self.maps[NORMAL][ord('#')] = hash_map
        def asterisk_map(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            scope = self.get_curr_buffer().inner_word(x, y)
            pattern = self.get_curr_buffer().get_scope_text(scope[0],
                                                            scope[1],
                                                            scope[2],
                                                            scope[3])
            if len(pattern) == 0: return False
            pattern = pattern[0]
            self.registers['/'] = pattern
            self._search_forward = True
            self._on_search(x, y, pattern, self._search_forward)
            return False
        self.maps[NORMAL][ord('*')] = asterisk_map
        def precent_map(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            char = self.get_curr_window().get_curr_line()[x]
            dst_char = self.get_curr_buffer().negate_char(char)
            if not dst_char: return False
            x_dst = x
            y_dst = y
            if char in "(<{[":
                ret = self.get_curr_buffer().find_next_char(x, y, dst_char, smart=True)
                if not ret: return False
                x_dst, y_dst = ret
            else:
                ret = self.get_curr_buffer().find_prev_char(x, y, dst_char, smart=True)
                if not ret: return False
                x_dst, y_dst = ret
            self.get_curr_window().move_cursor_to_buf_location(x_dst, y_dst)
            return False
        self.maps[NORMAL][ord('%')] = precent_map
        def H_map(self):
            self.get_curr_window().add_jump()
            self.get_curr_window().move_begin_visible()
            self.get_curr_window().add_jump()
            return False
        self.maps[NORMAL][ord('H')] = H_map
        def M_map(self):
            self.get_curr_window().add_jump()
            self.get_curr_window().move_middle_visible()
            self.get_curr_window().add_jump()
            return False
        self.maps[NORMAL][ord('M')] = M_map
        def L_map(self):
            self.get_curr_window().add_jump()
            self.get_curr_window().move_end_visible()
            self.get_curr_window().add_jump()
            return False
        self.maps[NORMAL][ord('L')] = L_map
        def o_map(self):
            self.change_mode(INSERT)
            self.get_curr_window().new_line_after()
            return False
        self.maps[NORMAL][ord('o')] = o_map
        def O_map(self):
            self.change_mode(INSERT)
            self.get_curr_window().new_line_before()
            return False
        self.maps[NORMAL][ord('O')] = O_map
        def A_map(self):
            self.change_mode(INSERT)
            self.get_curr_window().move_line_end()
            return False
        self.maps[NORMAL][ord('A')] = A_map
        def a_map(self):
            self.change_mode(INSERT)
            self.get_curr_window().move_right()
            return False
        self.maps[NORMAL][ord('a')] = a_map
        def I_map(self):
            self.change_mode(INSERT)
            self.get_curr_window().move_line_begin(ignore_spaces=True)
            return False
        self.maps[NORMAL][ord('I')] = I_map
        def i_map(self):
            self.change_mode(INSERT)
            return False
        self.maps[NORMAL][ord('i')] = i_map
        def s_map(self):
            self.change_begin()
            self.get_curr_window().remove_char_special(self.get_curr_window().buffer_cursor[0] + 1)
            self.change_mode(INSERT, effect_change=False)
            return False
        self.maps[NORMAL][ord('s')] = s_map
        def X_map(self):
            self.change_begin()
            self.get_curr_window().remove_char_special(self.get_curr_window().buffer_cursor[0])
            self.change_end()
            return False
        self.maps[NORMAL][ord('X')] = X_map
        def x_map(self):
            self.change_begin()
            self.get_curr_window().remove_char_special(self.get_curr_window().buffer_cursor[0] + 1)
            self.change_end()
            return False
        self.maps[NORMAL][ord('x')] = x_map
        def r_map(self):
            self.change_begin()
            self.get_curr_window().replace()
            self.change_end()
            return False
        self.maps[NORMAL][ord('r')] = r_map
        def R_map(self):
            self.change_mode(REPLACE)
            return False
        self.maps[NORMAL][ord('R')] = R_map
        def P_map(self):
            self.change_begin()
            data = self.registers['"']
            if data:
                if data['meta'] == 'line':
                    lines = data['data']
                    for line in reversed(lines):
                        self.get_curr_window().insert_line_before(line, propagate=False)
                    self.get_curr_buffer().flush_changes()
                elif data['meta'] == 'char':
                    lines = data['data']
                    string = '\n'.join(lines)
                    self.get_curr_window().insert_string(string)
                elif data['meta'] == 'block': pass
            self.change_end()
            return False
        self.maps[NORMAL][ord('P')] = P_map
        def p_map(self):
            self.change_begin()
            data = self.registers['"']
            if data:
                if data['meta'] == 'line':
                    lines = data['data']
                    for line in lines:
                        self.get_curr_window().insert_line_after(line, propagate=False)
                    self.get_curr_buffer().flush_changes()
                elif data['meta'] == 'char':
                    lines = data['data']
                    string = '\n'.join(lines)
                    self.get_curr_window().move_right()
                    self.get_curr_window().insert_string(string)
                elif data['meta'] == 'block': pass
            self.change_end()
            return False
        self.maps[NORMAL][ord('p')] = p_map
        def u_map(self):
            self.get_curr_window().undo()
            return False
        self.maps[NORMAL][ord('u')] = u_map
        def V_map(self):
            self.change_mode(VISUAL_LINE)
            return False
        self.maps[NORMAL][ord('V')] = V_map
        def v_map(self):
            self.change_mode(VISUAL)
            return False
        self.maps[NORMAL][ord('v')] = v_map
        def n_map(self):
            last_pattern = self.registers['/']
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self._on_search(x, y, last_pattern, self._search_forward)
            return False
        self.maps[NORMAL][ord('n')] = n_map
        def N_map(self):
            last_pattern = self.registers['/']
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self._on_search(x, y, last_pattern, not self._search_forward)
            return False
        self.maps[NORMAL][ord('N')] = N_map
        def J_map(self):
            self.change_begin()

            self.get_curr_window().join_line()

            self.change_end()
            return False
        self.maps[NORMAL][ord('J')] = J_map
        def C_map(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]

            size = self.get_curr_window().get_curr_line_len()
            start_x = x
            start_y = y
            end_x = size - 2
            end_y = y

            self.change_begin()
            self.get_curr_window().remove_scope(start_x, start_y, end_x, end_y)
            # self.change_end()
            self.change_mode(INSERT, effect_change=False)
            return False
        self.maps[NORMAL][ord('C')] = C_map
        def D_map(self):
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]

            size = self.get_curr_window().get_curr_line_len()
            start_x = x
            start_y = y
            end_x = size - 2
            end_y = y

            self.change_begin()
            self.get_curr_window().remove_scope(start_x, start_y, end_x, end_y)
            self.change_end()

            return False
        self.maps[NORMAL][ord('D')] = D_map
        def dot_map(self):
            for k in self.registers['.']: self.on_key(k)
            return False
        self.maps[NORMAL][ord('.')] = dot_map

        self.maps[NORMAL][ord('z')] = {}
        def zz_map(self):
            self.get_curr_window().align_center()
            return False
        self.maps[NORMAL][ord('z')][ord('z')] = zz_map
        def zb_map(self):
            self.get_curr_window().align_bottom()
            return False
        self.maps[NORMAL][ord('z')][ord('b')] = zb_map
        def zt_map(self):
            self.get_curr_window().align_top()
            return False
        self.maps[NORMAL][ord('z')][ord('t')] = zt_map

        self._initialize_normal_ctrl_maps()
        self._initialize_normal_symbol_maps()

    def _initialize_leader_maps(self):
        self.maps[NORMAL][ord(' ')] = {}        # leader
        self.maps[NORMAL][ord(' ')][ord('o')] = {} # open
        self.maps[NORMAL][ord(' ')][ord('e')] = {} # execute
        self.maps[NORMAL][ord(' ')][ord('s')] = {} # search
        self.maps[NORMAL][ord(' ')][ord('t')] = {} # treesitter
        def leader_sf_map(self): # search file
            file_path = fzf()
            if file_path:
                buffer = self.get_or_create_buffer(file_path)
                self.get_curr_window().add_jump()
                self.get_curr_window().change_buffer(buffer)
                self.get_curr_window().add_jump()
            return False
        self.maps[NORMAL][ord(' ')][ord('s')][ord('f')] = leader_sf_map
        def leader_sc_map(self): # search content
            try:
                text = self.prompt("rg: ")
                if len(text) == 0: return False

                task = Task(ripgrep, text)
                self.tasks.append(task)
                def rg_on_done(results):
                    if not results: return
                    self.get_curr_tab().split(Buffer(data_in_bytes=results))

                    # remove the task when done.
                    self.tasks.remove(task)

                task.on_done(rg_on_done)
                task.start()
            except Exception as e: elog(f"Exception: {e}")
            return False
        self.maps[NORMAL][ord(' ')][ord('s')][ord('c')] = leader_sc_map
        def leader_ts_map(self): # search content
            abs_position = [0,0]
            window_x = self.get_curr_window().position[0]
            window_y = self.get_curr_window().position[1]
            window_cursor_x = 0
            window_cursor_y = 0
            abs_position[0] = window_x + window_cursor_x
            abs_position[1] = window_y + window_cursor_y
            try:
                ts = TreeSitterPopup(   self,
                                        self.screen,
                                        self.get_curr_buffer().treesitter,
                                        self.get_curr_window().buffer_cursor)
                node = ts.pop()
                if node:
                    y = node.start_point[0]
                    x = node.start_point[1]
                    self.get_curr_window().move_cursor_to_buf_location(x, y)
                    self.get_curr_window().align_center()

                self.get_curr_tab().draw() # need to redraw after popup
            except Exception as e: elog(f"Exception: {e}")
            return False
        self.maps[NORMAL][ord(' ')][ord('t')][ord('s')] = leader_ts_map
        def leader_d_map(self):
            details = DetailsPopup(self)
            details.pop()
            self.get_curr_tab().draw() # need to redraw after popup
            return False
        self.maps[NORMAL][ord(' ')][ord('d')] = leader_d_map
        def leader_oc_map(self):
            config_path = os.path.expanduser('~/.config/editor/config.json')
            buffer = self.get_or_create_buffer(config_path)
            self.get_curr_tab().vsplit(buffer)
            return False
        # open config
        self.maps[NORMAL][ord(' ')][ord('o')][ord('c')] = leader_oc_map
        def leader_r_map(self):
            text = self.prompt("replace: ")
            if len(text) == 0: return False
            last_pattern = self.registers['/']
            if not last_pattern or len(last_pattern) == 0: return False

            start = self.get_curr_buffer().get_file_x_y(0)
            if not start: return False
            start_x, start_y = start

            end_pos = len(self.get_curr_buffer().get_file_stream()) - 1
            end = self.get_curr_buffer().get_file_x_y(end_pos)
            if not end: return False
            end_x, end_y = end

            self.change_begin()
            self.get_curr_window().search_replace_scope(start_x,
                                                        start_y,
                                                        end_x,
                                                        end_y,
                                                        last_pattern,
                                                        text)
            self.change_end()
            return False
        # replace editor pattern
        self.maps[NORMAL][ord(' ')][ord('r')] = leader_r_map
        def leader_l_map(self):
            self.get_curr_window().buffer_cursor[1]
            lines = LinesPopup( self,
                                self.screen,
                                self.get_curr_buffer().lines,
                                self.get_curr_window().buffer_cursor[1])
            y = lines.pop()
            self.get_curr_window().move_cursor_to_buf_location(0, y)

            self.get_curr_tab().draw() # need to redraw after popup
            return False
        self.maps[NORMAL][ord(' ')][ord('l')] = leader_l_map
        def leader_ec_map(self):
            load_settings()
            return False
        # reload settings of editor ([e]xecute [c]onfig (legacy))
        self.maps[NORMAL][ord(' ')][ord('e')][ord('c')] = leader_ec_map

    def _initialize_normal_maps(self):
        def colon_map(self):
            return self.on_command()
        self.maps[NORMAL][ord(':')] = colon_map

        def enter_map(self):
            if not self.get_curr_window().line_numbers:
                self.get_curr_window().enable_lines_numbers()
            else:
                self.get_curr_window().disable_lines_numbers()
            if not self.get_curr_window().status_line:
                self.get_curr_window().enable_status_line()
            else:
                self.get_curr_window().disable_status_line()

            return False
        self.maps[NORMAL][ENTER_KEY] = enter_map

        self._initialize_legends_maps(NORMAL)
        self._initialize_normal_mainstream_maps()
        self._initialize_normal_window_maps()
        self._initialize_leader_maps()

    def _initialize_insert_ctrl_maps(self):
        def ctrl_w_map(self):
            window = self.get_curr_window()

            start_x, start_y = window.buffer_cursor[0] - 1, window.buffer_cursor[1]

            ret = window.buffer.find_prev_word(start_x, start_y)
            if not ret: return
            end_x, end_y = ret

            window.remove_scope(end_x, end_y, start_x, start_y)
            self.get_curr_window().draw_cursor()
            return False
        self.maps[INSERT][CTRL_W_KEY] = ctrl_w_map
        def ctrl_n_map(self):
            ret = self.generate_completion_options()
            if not ret: return False
            x, options = ret
            if len(options) == 0: return False
            if len(options) == 1:
                self.get_curr_window().insert_string(options[0][1])
                return False

            window_x = self.get_curr_window().content_position[0]
            window_y = self.get_curr_window().content_position[1]
            buf_y = self.get_curr_window().buffer_cursor[1]

            abs_position = [0,0]
            expanded_x = self.get_curr_window()._expanded_x(buf_y, x)
            abs_position[0] = window_x + expanded_x
            abs_position[1] = window_y + self.get_curr_window().window_cursor[1]

            completion = CompletionPopup(   self,
                                            self.screen,
                                            position=abs_position,
                                            options=options)
            choise = completion.pop()
            self.get_curr_tab().draw() # need to redraw after completion

            if choise:
                self.get_curr_window().insert_string(choise[1])
            return False
        self.maps[INSERT][CTRL_N_KEY] = ctrl_n_map

    def _initialize_insert_maps(self):
        self._initialize_insert_ctrl_maps()

    def _initialize_visual_line_maps(self):
        self.maps[VISUAL_LINE][ord(' ')] = {} # leader
        def d_map(self):
            scope = self.get_curr_buffer().visual_get_scope()
            if not scope: return False
            start_x, start_y, end_x, end_y = scope

            lines = []
            for y in range(start_y, end_y + 1):
                lines.append(self.get_curr_buffer().lines[y])

            self.change_begin()
            for y in reversed(range(start_y, end_y + 1)):
                self.get_curr_window().remove_line_at(y, propagate=False)
            self.get_curr_buffer().flush_changes()

            self.change_end()

            # send yanked text to clipboard
            clipboard(lines)

            data = {}
            data['meta'] = 'line'
            data['data'] = lines
            self.registers['"'] = data

            self.change_mode(NORMAL)
            return False
        self.maps[VISUAL_LINE][ord('d')] = d_map
        def y_map(self):
            scope = self.get_curr_buffer().visual_get_scope()
            if not scope: return False
            start_x, start_y, end_x, end_y = scope

            lines = []
            for y in range(start_y, end_y + 1):
                lines.append(self.get_curr_buffer().lines[y])
            if len(lines) == 0: return False

            # send yanked text to clipboard
            clipboard(lines)

            data = {}
            data['meta'] = 'line'
            data['data'] = lines
            self.registers['"'] = data

            self.change_mode(NORMAL)
            return False
        self.maps[VISUAL_LINE][ord('y')] = y_map
        def j_map(self):
            num = 1
            if len(self._number) > 0: num = int(self._number)
            for _ in range(num): self.get_curr_window()._move_down()
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.get_curr_buffer().visual_set_current(x, y)
            self.draw()
            return False
        self.maps[VISUAL_LINE][ord('j')] = j_map
        def k_map(self):
            num = 1
            if len(self._number) > 0: num = int(self._number)
            for _ in range(num): self.get_curr_window()._move_up()
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.get_curr_buffer().visual_set_current(x, y)
            self.draw()
            return False
        self.maps[VISUAL_LINE][ord('k')] = k_map
        def l_map(self):
            self.get_curr_window()._move_right()
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.get_curr_buffer().visual_set_current(x, y)
            self.draw()
            return False
        self.maps[VISUAL_LINE][ord('l')] = l_map
        def h_map(self):
            self.get_curr_window()._move_left()
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.get_curr_buffer().visual_set_current(x, y)
            self.draw()
            return False
        self.maps[VISUAL_LINE][ord('h')] = h_map
        def ctrl_u_map(self):
            self.get_curr_window()._scroll_up_half_page()
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.get_curr_buffer().visual_set_current(x, y)
            self.draw()
            return False
        self.maps[VISUAL_LINE][CTRL_U_KEY] = ctrl_u_map
        def ctrl_d_map(self):
            self.get_curr_window()._scroll_down_half_page()
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.get_curr_buffer().visual_set_current(x, y)
            self.draw()
            return False
        self.maps[VISUAL_LINE][CTRL_D_KEY] = ctrl_d_map
        self.maps[VISUAL_LINE][ord('g')] = {}
        def gq_map(self):
            scope = self.get_curr_buffer().visual_get_scope()
            if not scope: return False
            start_x, start_y, end_x, end_y = scope

            start_x = 0
            end_x = len(self.get_curr_window().get_line(end_y)) - 2

            self.get_curr_window().move_cursor_to_buf_location(start_x, start_y)
            self.change_begin()
            try:
                format(self, start_x, start_y, end_x, end_y)
            except Exception as e:
                elog(f"Exception: {e}")
            self.change_end()

            self.change_mode(NORMAL)
            return False
        self.maps[VISUAL_LINE][ord('g')][ord('q')] = gq_map
        def gc_map(self):
            scope = self.get_curr_buffer().visual_get_scope()
            if not scope: return False
            start_x, start_y, end_x, end_y = scope
            self.change_begin()

            try:
                comment(self, start_y, end_y)
            except Exception as e:
                elog(f"Exception: {e}")

            self.change_end()

            self.change_mode(NORMAL)
            return False
        self.maps[VISUAL_LINE][ord('g')][ord('c')] = gc_map
        def gg_map(self):
            self.get_curr_window().move_begin()
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.get_curr_buffer().visual_set_current(x, y)
            self.draw()
            return False
        self.maps[VISUAL_LINE][ord('g')][ord('g')] = gg_map
        def G_map(self):
            self.get_curr_window().move_end()
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.get_curr_buffer().visual_set_current(x, y)
            self.draw()
            return False
        self.maps[VISUAL_LINE][ord('G')] = G_map
        self.maps[VISUAL_LINE][ord('>')] = {}
        self.maps[VISUAL_LINE][ord('<')] = {}
        def lt_map(self):
            scope = self.get_curr_buffer().visual_get_scope()
            if not scope: return False
            start_x, start_y, end_x, end_y = scope
            self.change_begin()
            self.get_curr_window().indent_lines(start_y, end_y, False)
            self.change_end()
        self.maps[VISUAL_LINE][ord('<')] = lt_map
        def gt_map(self):
            scope = self.get_curr_buffer().visual_get_scope()
            if not scope: return False
            start_x, start_y, end_x, end_y = scope
            self.change_begin()
            self.get_curr_window().indent_lines(start_y, end_y, True)
            self.change_end()
            return False
        self.maps[VISUAL_LINE][ord('>')] = gt_map
        def leader_r_map(self):
            scope = self.get_curr_buffer().visual_get_scope()
            if not scope: return False
            start_x, start_y, end_x, end_y = scope
            # Xs are matter in this case, so make them right
            start_x = 0
            end_x = len(self.get_curr_window().get_line(end_y)) - 1

            text = self.prompt("replace: ")
            if len(text) == 0: return False
            last_pattern = self.registers['/']
            if not last_pattern or len(last_pattern) == 0: return False

            self.change_begin()
            self.get_curr_window().search_replace_scope(start_x,
                                                        start_y,
                                                        end_x,
                                                        end_y,
                                                        last_pattern,
                                                        text)
            self.change_end()
            self.change_mode(NORMAL)
            return False
        self.maps[VISUAL_LINE][ord(' ')][ord('r')] = leader_r_map

    def _initialize_visual_maps(self):
        def visual_object_map(scope):
            start_x, start_y, end_x, end_y = scope

            self.get_curr_buffer().visual_set_scope(start_x, start_y, end_x, end_y)
            self.get_curr_window().move_cursor_to_buf_location(end_x, end_y)

            self.draw()
            return False
        self.__initialize_inner_around_objects_maps(self.maps[VISUAL], visual_object_map)
        def d_map(self):
            scope = self.get_curr_buffer().visual_get_scope()
            if not scope: return False
            self.change_begin()

            start_x, start_y, end_x, end_y = scope
            self.get_curr_window().remove_scope(start_x, start_y, end_x, end_y)

            self.change_end()

            self.change_mode(NORMAL)
            return False
        self.maps[VISUAL][ord('d')] = d_map
        def p_map(self):
            scope = self.get_curr_buffer().visual_get_scope()
            if not scope: return False
            start_x, start_y, end_x, end_y = scope

            self.change_begin()

            self.get_curr_window().remove_scope(start_x, start_y, end_x, end_y)
            data = self.registers['"']
            if data:
                if data['meta'] == 'line':
                    lines = data['data']
                    for line in reversed(lines):
                        self.get_curr_window().insert_line_before(line, propagate=False)
                    self.get_curr_buffer().flush_changes()
                elif data['meta'] == 'char':
                    lines = data['data']
                    string = '\n'.join(lines)
                    self.get_curr_window().insert_string(string)
                elif data['meta'] == 'block': pass

            self.change_end()

            self.change_mode(NORMAL)
            return False
        self.maps[VISUAL][ord('p')] = p_map
        def c_map(self):
            scope = self.get_curr_buffer().visual_get_scope()
            if not scope: return False
            self.change_begin()

            start_x, start_y, end_x, end_y = scope
            self.get_curr_window().remove_scope(start_x, start_y, end_x, end_y)

            self.change_mode(INSERT, effect_change=False)
            return False
        self.maps[VISUAL][ord('c')] = c_map
        def y_map(self):
            scope = self.get_curr_buffer().visual_get_scope()
            if not scope: return False

            start_x, start_y, end_x, end_y = scope
            text = self.get_curr_buffer().get_scope_text(start_x, start_y, end_x, end_y)
            if len(text) == 0: return False

            # send yanked text to clipboard
            clipboard(text)

            data = {}
            data['meta'] = 'char'
            data['data'] = text
            self.registers['"'] = data

            self.change_mode(NORMAL)
            return False
        self.maps[VISUAL][ord('y')] = y_map
        def j_map(self):
            self.get_curr_window()._move_down()
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.get_curr_buffer().visual_set_current(x, y)
            self.draw()
            return False
        self.maps[VISUAL][ord('j')] = j_map
        def k_map(self):
            self.get_curr_window()._move_up()
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.get_curr_buffer().visual_set_current(x, y)
            self.draw()
            return False
        self.maps[VISUAL][ord('k')] = k_map
        def l_map(self):
            self.get_curr_window()._move_right()
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.get_curr_buffer().visual_set_current(x, y)
            self.draw()
            return False
        self.maps[VISUAL][ord('l')] = l_map
        def h_map(self):
            self.get_curr_window()._move_left()
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.get_curr_buffer().visual_set_current(x, y)
            self.draw()
            return False
        self.maps[VISUAL][ord('h')] = h_map
        def w_map(self):
            self.get_curr_window().move_word_forward()
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.get_curr_buffer().visual_set_current(x, y)
            self.draw()
            return False
        self.maps[VISUAL][ord('w')] = w_map
        def W_map(self):
            self.get_curr_window().move_WORD_forward()
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.get_curr_buffer().visual_set_current(x, y)
            self.draw()
            return False
        self.maps[VISUAL][ord('W')] = W_map
        def e_map(self):
            self.get_curr_window().move_word_end()
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.get_curr_buffer().visual_set_current(x, y)
            self.draw()
            return False
        self.maps[VISUAL][ord('e')] = e_map
        def E_map(self):
            self.get_curr_window().move_WORD_end()
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.get_curr_buffer().visual_set_current(x, y)
            self.draw()
            return False
        self.maps[VISUAL][ord('E')] = E_map
        def b_map(self):
            self.get_curr_window().move_word_backward()
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.get_curr_buffer().visual_set_current(x, y)
            self.draw()
            return False
        self.maps[VISUAL][ord('b')] = b_map
        def f_map(self):
            try:
                char = self.get_curr_window().find()
                self._action = 'f'
                self._char = char

                x = self.get_curr_window().buffer_cursor[0]
                y = self.get_curr_window().buffer_cursor[1]
                self.get_curr_buffer().visual_set_current(x, y)
                self.draw()
            except Exception as e: elog(f"Exception: {e}")
            return False
        self.maps[VISUAL][ord('f')] = f_map
        def F_map(self):
            char = self.get_curr_window().find_back()
            self._action = 'F'
            self._char = char

            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.get_curr_buffer().visual_set_current(x, y)
            self.draw()
            return False
        self.maps[VISUAL][ord('F')] = F_map
        def t_map(self):
            char = self.get_curr_window().till()
            self._action = 't'
            self._char = char

            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.get_curr_buffer().visual_set_current(x, y)
            self.draw()
            return False
        self.maps[VISUAL][ord('t')] = t_map
        def T_map(self):
            char = self.get_curr_window().till_back()
            self._action = 'T'
            self._char = char

            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.get_curr_buffer().visual_set_current(x, y)
            self.draw()
            return False
        self.maps[VISUAL][ord('T')] = T_map
        def semicolon_map(self):
            if self._action == 'f':
                self.get_curr_window()._find(self._char)
            if self._action == 'F':
                self.get_curr_window()._find_back(self._char)
            if self._action == 't':
                self.get_curr_window()._till(self._char)
            if self._action == 'T':
                self.get_curr_window()._till_back(self._char)

            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.get_curr_buffer().visual_set_current(x, y)
            self.draw()
            return False
        self.maps[VISUAL][ord(';')] = semicolon_map
        def comma_map(self):
            if self._action == 'f':
                self.get_curr_window()._find_back(self._char)
            if self._action == 'F':
                self.get_curr_window()._find(self._char)
            if self._action == 't':
                self.get_curr_window()._till_back(self._char)
            if self._action == 'T':
                self.get_curr_window()._till(self._char)

            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.get_curr_buffer().visual_set_current(x, y)
            self.draw()
            return False
        self.maps[VISUAL][ord(',')] = comma_map
        def dollar_map(self):
            self.get_curr_window().move_line_end()
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.get_curr_buffer().visual_set_current(x, y)
            self.draw()
            return False
        self.maps[VISUAL][ord('$')] = dollar_map

        def leader_s_c_map(self):
            scope = self.get_curr_buffer().visual_get_scope()
            if not scope: return False

            start_x, start_y, end_x, end_y = scope
            text = self.get_curr_buffer().get_scope_text(start_x, start_y, end_x, end_y)
            if len(text) == 0: return False
            text = text[0]

            task = Task(ripgrep, text)
            self.tasks.append(task)
            def rg_on_done(results):
                if not results: return
                self.get_curr_tab().split(Buffer(data_in_bytes=results))

                # remove the task when done.
                self.tasks.remove(task)

            task.on_done(rg_on_done)
            task.start()

            self.change_mode(NORMAL)
            return False

        self.maps[VISUAL][ord(' ')] = {}
        self.maps[VISUAL][ord(' ')][ord('s')] = {}
        self.maps[VISUAL][ord(' ')][ord('s')][ord('c')] = leader_s_c_map
        def leader_r_map(self):
            scope = self.get_curr_buffer().visual_get_scope()
            if not scope: return False
            start_x, start_y, end_x, end_y = scope

            text = self.prompt("replace: ")
            if len(text) == 0: return False
            last_pattern = self.registers['/']
            if not last_pattern or len(last_pattern) == 0: return False

            self.change_begin()
            self.get_curr_window().search_replace_scope(start_x,
                                                        start_y,
                                                        end_x,
                                                        end_y,
                                                        last_pattern,
                                                        text)
            self.change_end()
            self.change_mode(NORMAL)
            return False
        self.maps[VISUAL][ord(' ')][ord('r')] = leader_r_map
        def slash_map(self):
            scope = self.get_curr_buffer().visual_get_scope()
            if not scope: return False

            start_x, start_y, end_x, end_y = scope
            text = self.get_curr_buffer().get_scope_text(start_x, start_y, end_x, end_y)
            if len(text) == 0: return False
            text = re.escape(text[0])

            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.change_mode(NORMAL)
            self.registers['/'] = text
            self._search_forward = True
            self._on_search(x, y, text, self._search_forward)
            return False
        self.maps[VISUAL][ord('/')] = slash_map
        def question_map(self):
            scope = self.get_curr_buffer().visual_get_scope()
            if not scope: return False

            start_x, start_y, end_x, end_y = scope
            text = self.get_curr_buffer().get_scope_text(start_x, start_y, end_x, end_y)
            if len(text) == 0: return False
            text = text[0]

            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            self.change_mode(NORMAL)
            self.registers['/'] = text
            self._search_forward = False
            self._on_search(x, y, text, self._search_forward)
            return False
        self.maps[VISUAL][ord('?')] = question_map

    def _initialize_replace_maps(self):
        pass

    def initialize_maps(self):
        self._initialize_normal_maps()
        self._initialize_insert_maps()
        self._initialize_visual_maps()
        self._initialize_visual_line_maps()
        self._initialize_replace_maps()

    def initialize_registers(self):
        # we dont add all of vim's registers for now..
        self.registers = {}
        self.internal_registers = {}

        # named registers
        for char in "abcdefghijklmnopqrstuvwxyz": self.registers[char] = None
        for char in "ABCDEFGHIJKLMNOPQRSTUVWXYZ": self.registers[char] = None
        # numbered registers
        for num in "0123456789": self.registers[num] = None
        # unamed register
        self.registers['"'] = None
        # last search pattern register
        self.registers['/'] = None
        # last change register
        self.registers['.'] = []
        self.internal_registers['.'] = []

    def __init__(self, screen):
        self.screen = screen
        self.screen.set_cursor_block_blink() # default for normal mode

        self.height, self.width = screen.get_height(), screen.get_width()
        Hooks.register(ON_RESIZE, self.screen_resize_handler)

        self.initialize_registers()
        self._number = ''
        self._action = 'f' # options are 'f','F','t','T'
        self._char = None
        self._search_forward = True

        self._replace_line = ""
        self._replace_x = -1
        self._replace_y = -1

        self.maps = {}
        self.maps[NORMAL] = {}
        self.maps[INSERT] = {}
        self.maps[VISUAL] = {}
        self.maps[VISUAL_LINE] = {}
        self.maps[VISUAL_BLOCK] = {}
        self.maps[REPLACE] = {}

        self.initialize_maps()

        # start in normal mode
        self.mode = NORMAL
        self.curr_maps = self.maps[self.mode]

        self.tabs = []
        self.windows = []
        self.buffers = []
        self.tasks = []

        self.curr_tab = -1

        # Register to global events!
        Hooks.register(ON_BUFFER_CREATE_AFTER, self.on_buffer_create_after_callback)
        Hooks.register(ON_BUFFER_DESTROY_AFTER, self.on_buffer_destroy_after_callback)

    def get_or_create_buffer(self, file_path):
        for buf in self.buffers:
            if buf.file_path == os.path.abspath(file_path):
                return buf
        return Buffer(file_path)
    def get_buffer_by_id(self, buffer_id):
        for buf in self.buffers:
            if buf.id == buffer_id:
                return buf
        return None

    def _create_tab(self, buffer=None):
        self.tabs.append(Tab(self.screen, self.width, self.height, buffer))
        self.get_curr_tab().hide()
        self.curr_tab = len(self.tabs) - 1
        self.get_curr_tab().show()

        self.get_curr_tab().draw()
        return self.get_curr_tab()

    def next_tab(self):
        self.get_curr_tab().hide()
        self.curr_tab = (self.curr_tab + 1) % len(self.tabs)
        self.get_curr_tab().show()
        self.get_curr_tab().draw()

    def prev_tab(self):
        self.get_curr_tab().hide()
        self.curr_tab = (self.curr_tab - 1) % len(self.tabs)
        self.get_curr_tab().show()
        self.get_curr_tab().draw()

    def get_curr_tab(self):
        return self.tabs[self.curr_tab]
    def get_curr_window(self):
        return self.get_curr_tab().get_curr_window()
    def get_curr_buffer(self):
        return self.get_curr_window().buffer

    def bootstrap(self):
        global args

        if not args.filename:
            buffer = Buffer()
            self._create_tab(buffer)
        else:
            file = args.filename[0]

            buffer = self.get_or_create_buffer(file)
            self._create_tab(buffer)

    def screen_resize_handler(self, size):
        self.width, self.height = size
        self.get_curr_tab().resize(self.width, self.height)
        self.get_curr_tab().draw()

    def _quit_command(self):
        tab = self.get_curr_tab()
        window = tab.get_curr_window()

        if len(tab.windows) > 1:
            tab.close_window(window)
            return False
        if len(self.tabs) == 1:
            tab.close()
            return True

        to_delete = self.tabs.pop(self.curr_tab)
        self.curr_tab = self.curr_tab % len(self.tabs)
        to_delete.close()
        self.get_curr_tab().draw()
        return False

    def exec_command(self, command):
        cmd = command.split()[0]
        args = command.split()[1:] if len(command.split()) > 1 else None
        force = cmd.endswith('!')

        if "e" in cmd:
            if not args:
                if not self.get_curr_buffer().reload(force=force):
                    elog("file changed on disk!", type="ERROR")
                    pass
                else:
                    # TODO:
                    pass
            return False
        if "w" in cmd:
            if not self.get_curr_buffer().write(force=force):
                elog("file changed on disk!", type="ERROR")
                pass
        if "q" in cmd:
            if not force and self.get_curr_buffer().file_changed_on_disk():
                elog("file changed on disk!", type="ERROR")
                return False
            return self._quit_command()
        if 'qa' in cmd:
            return True
        try:
            line_num = int(command)
            curr_x = self.get_curr_window().buffer_cursor[0]
            self.get_curr_window().move_cursor_to_buf_location(curr_x, line_num - 1)
        except: pass
        return False

    def draw_command(self, command):
        style = {}
        style['background'] = get_settings()['status_line_background']
        style['foreground'] = get_settings()['status_line_foreground']

        command_position = [0, 0]

        command_position[1] = int(self.height - 1)
        command_length = self.width

        self.screen.write(  command_position[1],
                            command_position[0],
                            command.ljust(command_length),
                            style)
        self.screen.move_cursor(    command_position[1],
                                    command_position[0] + len(command))

    def on_replace(self, key):
        # elog(f"on replace: {key}")
        cur_x = self.get_curr_window().buffer_cursor[0]
        cur_y = self.get_curr_window().buffer_cursor[1]
        if key == BACKSPACE_KEY:
            if cur_y == self._replace_y and cur_x == self._replace_x:
                return False
            if cur_y > self._replace_y:
                self.get_curr_window().remove_char()
                return False
            if cur_x > len(self._replace_line) - 1:
                self.get_curr_window().remove_char()
                return False
            prev_char = self._replace_line[cur_x - 1]
            self.get_curr_window().replace_char_backward(prev_char)
            return False

        if key == TAB_KEY:
            tab = get_settings()["tab_insert"]
            return False

        try:
            char = chr(key)
            if char in printable:
                if cur_x == len(self.get_curr_window().get_curr_line()) - 1:
                    self.get_curr_window().insert_char(char)
                else:
                    self.get_curr_window().replace_char_forward(char)
            else:
                elog(f"REPLACE: ({key}) not printable.")
        except Exception as e: elog(f"Exception: {e}")
        return False

    def on_insert(self, key):
        ret = False

        if key == BACKSPACE_KEY:
            line = self.get_curr_window().get_curr_line()
            x = self.get_curr_window().buffer_cursor[0]
            if line[x-4:x] == '    ':
                self.get_curr_window().remove_chars(4)
            else:
                self.get_curr_window().remove_char()

            return ret

        if key == TAB_KEY:
            # expand tab to spaces
            self.get_curr_window().insert_string(get_settings()["tab_insert"])
            return ret

        try:
            char = chr(key)
            # elog(f"INSERT: ({key}) -> {char}")
            if char in printable:
                self.get_curr_window().insert_char(char)
            else:
                elog(f"INSERT: ({key}) not printable.")
        except Exception as e: elog(f"Exception: {e}")
        return ret

    def _find_closest_match(self, x, y, matches, forward=True):
        if forward:
            for start_x, start_y, end_x, end_y in matches:
                if start_y < y: continue
                if start_y == y and start_x <= x: continue
                return (start_x, start_y)
            # wrap to start
            return matches[0][0], matches[0][1]
        else:
            for start_x, start_y, end_x, end_y in reversed(matches):
                if start_y > y: continue
                if start_y == y and start_x >= x: continue
                return (start_x, start_y)
            # wrap to end
            return matches[-1][0], matches[-1][1]

    def _on_search(self, x, y, pattern, forward):
        results = self.get_curr_buffer().search_pattern(pattern)
        if len(results) == 0: return False

        pos = self._find_closest_match(x, y, results, forward)
        if not pos: return False

        self.get_curr_window().move_cursor_to_buf_location( pos[0],
                                                            pos[1])

        # reverse the colors for highlights
        style = {}
        style['foreground'] = get_settings()['theme']['colors']['editor.foreground']
        style['background'] = get_settings()['theme']['colors']['selection.background']

        self.get_curr_buffer().add_highlights("/", pattern, style)
        self.get_curr_window().draw()
        return True

    def prompt(self, ask=None, on_change=None):
        text = ""
        to_return = ""
        while True:
            if ask: self.draw_command(f"{ask}{text}")
            else: self.draw_command(f"{text}")

            key = self.screen.get_key()

            if key == ENTER_KEY:
                to_return = text
                break
            if key == ESC_KEY: break
            if key == BACKSPACE_KEY:
                if len(text) > 0:
                    text = text[:-1]
                    if on_change: on_change(text)
            else:
                try:
                    char = chr(key)
                    if char in printable:
                        text += char
                        if on_change: on_change(text)
                except: continue
        self.get_curr_tab().draw()
        return to_return

    def on_search(self, forward):
        origin_x = self.get_curr_window().buffer_cursor[0]
        origin_y = self.get_curr_window().buffer_cursor[1]
        success = False
        def on_change(pattern):
            nonlocal success
            success = self._on_search(origin_x, origin_y, pattern, forward)
        pattern = self.prompt("/" if forward else "?", on_change)

        if len(pattern) > 0 and success:
            self.registers['/'] = pattern
            self._search_forward = forward
        else:
            self.get_curr_window().move_cursor_to_buf_location( origin_x,
                                                                origin_y)
            self.get_curr_buffer().clear_highlights()
            self.get_curr_window().draw()

    def on_command(self):
        command = self.prompt(":")
        if len(command) == 0: return False
        return self.exec_command(command)

    def on_key(self, key):
        # enter number mode
        if self.mode == NORMAL or self.mode == VISUAL_LINE:
            self._number = ''
            if ord('1') <= key <= ord('9'):
                while ord('0') <= key <= ord('9'):
                    self._number += chr(key)
                    key = self.screen.get_key()

        # dot functionality, recording.
        if self.mode == NORMAL:
            # If we on top level, start recording from top.
            if self.curr_maps == self.maps[self.mode]:
                self.internal_registers["."] = [key]
            # If we nested somewhere just append the key to the already
            # existing keys
            else:
                self.internal_registers["."].append(key)
        if self.mode == INSERT:
            self.internal_registers["."].append(key)

        if key == ESC_KEY:
            self.change_mode(NORMAL)
            return False

        if key in self.curr_maps:
            if callable(self.curr_maps[key]):
                func = self.curr_maps[key]
                # if we reached the level where we have a callable, that means
                # we return to top level of the mappings
                self.curr_maps = self.maps[self.mode]
                return func(self)

            if isinstance(self.curr_maps[key], dict):
                # this means we need to keep nesting
                self.curr_maps = self.curr_maps[key]
                return False

            # We reached a dead-end. start from the top again in normal
            # mode.
            self.change_mode(NORMAL)
            return False
        # If we have no mappings matches, it is only find under insert-mode
        # where we free to input free text.
        elif self.mode == INSERT:
            return self.on_insert(key)
        elif self.mode == REPLACE:
            return self.on_replace(key)

        # We reached a dead-end. start from the top again in normal
        # mode.
        self.change_mode(NORMAL)
        return False

    def generate_completion_options(self):
        options = []

        try:
            x = self.get_curr_window().buffer_cursor[0]
            y = self.get_curr_window().buffer_cursor[1]
            start_x = x

            words = []
            for buf in self.buffers:
                words.extend(re.findall('\w+', buf.get_file_stream()))
            if len(words) == 0: return None

            line = self.get_curr_window().get_curr_line()
            if re.match('\s', line[x - 1]):
                options = [(option, option) for option in words]
                start_x = x
            else:
                ret = self.get_curr_buffer().find_prev_word(x, y)
                if not ret: return None

                start_x, start_y = ret
                curr_word = line[start_x:x]
                for word in words:
                    if word.startswith(curr_word) and word != curr_word:
                        options.append((word, word[len(curr_word):]))
            return (start_x, list(set(options)))
        except Exception as e: elog(f"Exception: {e}")
        return None


def main():
    global args

    parser = argparse.ArgumentParser()
    parser.add_argument('filename', nargs='*')
    args = parser.parse_args()

    screen = Screen()
    editor = Editor(screen)
    editor.bootstrap()

    k = 0
    while True:
        try:
            to_exit = editor.on_key(k)
            if to_exit: break
        except Exception as e:
            # TODO: pop error!
            elog(f"Exception: {e}", type="ERROR")
            elog(f"traceback: {traceback.format_exc()}", type="ERROR")

        k = screen.get_key()
        # elog(f"key {k}")

    screen.clear()
    screen.move_cursor(0,0)


if __name__ == "__main__":
    # import cProfile
    # with cProfile.Profile() as profile:
        main()
    # profile.dump_stats("/tmp/stats.csv")

